{"version":3,"sources":["../../../src/mcp/claude-flow-tools.ts"],"sourcesContent":["/**\n * Claude-Flow specific MCP tools\n */\n\nimport type { MCPTool, MCPContext, AgentProfile, Task, MemoryEntry } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { getAvailableAgentTypes, getAgentTypeSchema } from '../constants/agent-types.js';\nimport type { Permissions } from './auth.js';\n\nexport interface ClaudeFlowToolContext extends MCPContext {\n  orchestrator?: any; // Reference to orchestrator instance\n}\n\n/**\n * Enhance tool schema with dynamic agent types\n */\nasync function enhanceToolWithAgentTypes(tool: MCPTool): Promise<MCPTool> {\n  const availableTypes = await getAvailableAgentTypes();\n  \n  // Clone the tool to avoid modifying the original\n  const enhancedTool = JSON.parse(JSON.stringify(tool));\n  \n  // Find and populate enum fields for agent types\n  function addEnumToAgentTypeFields(obj: any) {\n    if (typeof obj !== 'object' || obj === null) return;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        // Check if this is an agent type field\n        if (key === 'type' || key === 'filterByType' || key === 'assignToAgentType') {\n          const field = value as any;\n          if (field.type === 'string' && field.description?.includes('loaded dynamically from .claude/agents/')) {\n            field.enum = availableTypes;\n          }\n        }\n        addEnumToAgentTypeFields(value);\n      }\n    }\n  }\n  \n  addEnumToAgentTypeFields(enhancedTool.inputSchema);\n  return enhancedTool;\n}\n\n/**\n * Create all Claude-Flow specific MCP tools\n */\nexport async function createClaudeFlowTools(logger: ILogger): Promise<MCPTool[]> {\n  const tools = [\n    // Agent management tools\n    createSpawnAgentTool(logger),\n    createListAgentsTool(logger),\n    createTerminateAgentTool(logger),\n    createGetAgentInfoTool(logger),\n\n    // Task management tools\n    createCreateTaskTool(logger),\n    createListTasksTool(logger),\n    createGetTaskStatusTool(logger),\n    createCancelTaskTool(logger),\n    createAssignTaskTool(logger),\n\n    // Memory management tools\n    createQueryMemoryTool(logger),\n    createStoreMemoryTool(logger),\n    createDeleteMemoryTool(logger),\n    createExportMemoryTool(logger),\n    createImportMemoryTool(logger),\n\n    // System monitoring tools\n    createGetSystemStatusTool(logger),\n    createGetMetricsTool(logger),\n    createHealthCheckTool(logger),\n\n    // Configuration tools\n    createGetConfigTool(logger),\n    createUpdateConfigTool(logger),\n    createValidateConfigTool(logger),\n\n    // Workflow tools\n    createExecuteWorkflowTool(logger),\n    createCreateWorkflowTool(logger),\n    createListWorkflowsTool(logger),\n\n    // Terminal management tools\n    createExecuteCommandTool(logger),\n    createListTerminalsTool(logger),\n    createCreateTerminalTool(logger),\n  ];\n\n  // Enhance tools with dynamic agent types\n  const enhancedTools = await Promise.all(\n    tools.map(tool => enhanceToolWithAgentTypes(tool))\n  );\n\n  return enhancedTools;\n}\n\nfunction createSpawnAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn',\n    description: 'Spawn a new Claude agent with specified configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to spawn (loaded dynamically from .claude/agents/)',\n        },\n        name: {\n          type: 'string',\n          description: 'Display name for the agent',\n        },\n        capabilities: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of capabilities for the agent',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'Custom system prompt for the agent',\n        },\n        maxConcurrentTasks: {\n          type: 'number',\n          default: 3,\n          description: 'Maximum number of concurrent tasks',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Agent priority level (1-10)',\n        },\n        environment: {\n          type: 'object',\n          description: 'Environment variables for the agent',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory for the agent',\n        },\n      },\n      required: ['type', 'name'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const profile: AgentProfile = {\n        id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        name: input.name,\n        type: input.type,\n        capabilities: input.capabilities || [],\n        systemPrompt: input.systemPrompt || getDefaultSystemPrompt(input.type),\n        maxConcurrentTasks: input.maxConcurrentTasks || 3,\n        priority: input.priority || 5,\n        environment: input.environment,\n        workingDirectory: input.workingDirectory,\n      };\n\n      const sessionId = await context.orchestrator.spawnAgent(profile);\n\n      return {\n        agentId: profile.id,\n        sessionId,\n        profile,\n        status: 'spawned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/list',\n    description: 'List all active agents in the system',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeTerminated: {\n          type: 'boolean',\n          default: false,\n          description: 'Include terminated agents in the list',\n        },\n        filterByType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Filter agents by type (loaded dynamically from .claude/agents/)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing agents', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agents = await context.orchestrator.listAgents();\n\n      let filteredAgents = agents;\n\n      if (!input.includeTerminated) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.status !== 'terminated');\n      }\n\n      if (input.filterByType) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.type === input.filterByType);\n      }\n\n      return {\n        agents: filteredAgents,\n        count: filteredAgents.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createTerminateAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/terminate',\n    description: 'Terminate a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to terminate',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for termination',\n        },\n        graceful: {\n          type: 'boolean',\n          default: true,\n          description: 'Whether to perform graceful shutdown',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Terminating agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.terminateAgent(input.agentId, {\n        reason: input.reason || 'Manual termination',\n        graceful: input.graceful !== false,\n      });\n\n      return {\n        agentId: input.agentId,\n        status: 'terminated',\n        reason: input.reason || 'Manual termination',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetAgentInfoTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/info',\n    description: 'Get detailed information about a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting agent info', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agentInfo = await context.orchestrator.getAgentInfo(input.agentId);\n\n      if (!agentInfo) {\n        throw new Error(`Agent not found: ${input.agentId}`);\n      }\n\n      return {\n        agent: agentInfo,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/create',\n    description: 'Create a new task for execution',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          description: 'Type of task to create',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the task',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Task priority (1-10)',\n        },\n        dependencies: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of task IDs this task depends on',\n        },\n        assignToAgent: {\n          type: 'string',\n          description: 'Specific agent ID to assign the task to',\n        },\n        assignToAgentType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to assign the task to (loaded dynamically from .claude/agents/)',\n        },\n        input: {\n          type: 'object',\n          description: 'Input data for the task',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Task timeout in milliseconds',\n        },\n      },\n      required: ['type', 'description'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task: Partial<Task> = {\n        type: input.type,\n        description: input.description,\n        priority: input.priority || 5,\n        dependencies: input.dependencies || [],\n        input: input.input || {},\n        status: 'pending',\n        createdAt: new Date(),\n      };\n\n      const taskId = await context.orchestrator.createTask(task);\n\n      // Handle assignment\n      if (input.assignToAgent) {\n        await context.orchestrator.assignTask(taskId, input.assignToAgent);\n      } else if (input.assignToAgentType) {\n        await context.orchestrator.assignTaskToType(taskId, input.assignToAgentType);\n      }\n\n      return {\n        taskId,\n        task: { ...task, id: taskId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTasksTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/list',\n    description: 'List tasks with optional filtering',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        status: {\n          type: 'string',\n          enum: ['pending', 'queued', 'assigned', 'running', 'completed', 'failed', 'cancelled'],\n          description: 'Filter by task status',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by assigned agent ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by task type',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of tasks to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of tasks to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing tasks', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const tasks = await context.orchestrator.listTasks({\n        status: input.status,\n        agentId: input.agentId,\n        type: input.type,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      });\n\n      return {\n        tasks,\n        count: tasks.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetTaskStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/status',\n    description: 'Get detailed status of a specific task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting task status', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task = await context.orchestrator.getTask(input.taskId);\n\n      if (!task) {\n        throw new Error(`Task not found: ${input.taskId}`);\n      }\n\n      return {\n        task,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCancelTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/cancel',\n    description: 'Cancel a pending or running task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for cancellation',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Cancelling task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.cancelTask(input.taskId, input.reason || 'Manual cancellation');\n\n      return {\n        taskId: input.taskId,\n        status: 'cancelled',\n        reason: input.reason || 'Manual cancellation',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createAssignTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/assign',\n    description: 'Assign a task to a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to assign',\n        },\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to assign the task to',\n        },\n      },\n      required: ['taskId', 'agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Assigning task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.assignTask(input.taskId, input.agentId);\n\n      return {\n        taskId: input.taskId,\n        agentId: input.agentId,\n        status: 'assigned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createQueryMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/query',\n    description: 'Query agent memory with filters and search',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Filter by entry type',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Filter by tags',\n        },\n        search: {\n          type: 'string',\n          description: 'Full-text search query',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries before this time',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of entries to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of entries to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Querying memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const query = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        tags: input.tags,\n        search: input.search,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      };\n\n      const entries = await context.orchestrator.queryMemory(query);\n\n      return {\n        entries,\n        count: entries.length,\n        query,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createStoreMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/store',\n    description: 'Store a new memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Agent ID for the memory entry',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for the memory entry',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Type of memory entry',\n        },\n        content: {\n          type: 'string',\n          description: 'Content of the memory entry',\n        },\n        context: {\n          type: 'object',\n          description: 'Context data for the memory entry',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Tags for the memory entry',\n        },\n        parentId: {\n          type: 'string',\n          description: 'Parent memory entry ID',\n        },\n      },\n      required: ['agentId', 'sessionId', 'type', 'content'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Storing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const entry: Partial<MemoryEntry> = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        content: input.content,\n        context: input.context || {},\n        tags: input.tags || [],\n        parentId: input.parentId,\n        timestamp: new Date(),\n        version: 1,\n      };\n\n      const entryId = await context.orchestrator.storeMemory(entry);\n\n      return {\n        entryId,\n        entry: { ...entry, id: entryId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createDeleteMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/delete',\n    description: 'Delete a memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        entryId: {\n          type: 'string',\n          description: 'ID of the memory entry to delete',\n        },\n      },\n      required: ['entryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Deleting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.deleteMemory(input.entryId);\n\n      return {\n        entryId: input.entryId,\n        status: 'deleted',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/export',\n    description: 'Export memory entries to a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        format: {\n          type: 'string',\n          enum: ['json', 'csv', 'markdown'],\n          default: 'json',\n          description: 'Export format',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries before this time',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Exporting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const exportResult = await context.orchestrator.exportMemory({\n        format: input.format || 'json',\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n      });\n\n      return {\n        ...exportResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createImportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/import',\n    description: 'Import memory entries from a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to the file to import',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          default: 'json',\n          description: 'Import format',\n        },\n        mergeStrategy: {\n          type: 'string',\n          enum: ['skip', 'overwrite', 'version'],\n          default: 'skip',\n          description: 'Strategy for handling duplicate entries',\n        },\n      },\n      required: ['filePath'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Importing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const importResult = await context.orchestrator.importMemory({\n        filePath: input.filePath,\n        format: input.format || 'json',\n        mergeStrategy: input.mergeStrategy || 'skip',\n      });\n\n      return {\n        ...importResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetSystemStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/status',\n    description: 'Get comprehensive system status information',\n    inputSchema: {\n      type: 'object',\n      properties: {},\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system status', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const status = await context.orchestrator.getSystemStatus();\n\n      return {\n        ...status,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetMetricsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/metrics',\n    description: 'Get system performance metrics',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        timeRange: {\n          type: 'string',\n          enum: ['1h', '6h', '24h', '7d'],\n          default: '1h',\n          description: 'Time range for metrics',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system metrics', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const metrics = await context.orchestrator.getMetrics(input.timeRange || '1h');\n\n      return {\n        metrics,\n        timeRange: input.timeRange || '1h',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createHealthCheckTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/health',\n    description: 'Perform a comprehensive health check',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        deep: {\n          type: 'boolean',\n          default: false,\n          description: 'Perform deep health check including component tests',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Performing health check', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const healthCheck = await context.orchestrator.performHealthCheck(input.deep || false);\n\n      return {\n        ...healthCheck,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/get',\n    description: 'Get current system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Specific configuration section to retrieve',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const config = await context.orchestrator.getConfig(input.section);\n\n      return {\n        config,\n        section: input.section,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createUpdateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/update',\n    description: 'Update system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Configuration section to update',\n        },\n        config: {\n          type: 'object',\n          description: 'Configuration values to update',\n        },\n        restart: {\n          type: 'boolean',\n          default: false,\n          description: 'Restart affected components after update',\n        },\n      },\n      required: ['section', 'config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Updating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.updateConfig(\n        input.section,\n        input.config,\n        input.restart || false,\n      );\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createValidateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/validate',\n    description: 'Validate a configuration object',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        config: {\n          type: 'object',\n          description: 'Configuration object to validate',\n        },\n      },\n      required: ['config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Validating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const validation = await context.orchestrator.validateConfig(input.config);\n\n      return {\n        ...validation,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/execute',\n    description: 'Execute a workflow from a file or definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to workflow file',\n        },\n        workflow: {\n          type: 'object',\n          description: 'Inline workflow definition',\n        },\n        parameters: {\n          type: 'object',\n          description: 'Parameters to pass to the workflow',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      if (!input.filePath && !input.workflow) {\n        throw new Error('Either filePath or workflow must be provided');\n      }\n\n      const result = await context.orchestrator.executeWorkflow({\n        filePath: input.filePath,\n        workflow: input.workflow,\n        parameters: input.parameters || {},\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/create',\n    description: 'Create a new workflow definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Name of the workflow',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the workflow',\n        },\n        tasks: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string' },\n              type: { type: 'string' },\n              description: { type: 'string' },\n              dependencies: {\n                type: 'array',\n                items: { type: 'string' },\n              },\n              assignTo: { type: 'string' },\n            },\n            required: ['id', 'type', 'description'],\n          },\n          description: 'List of tasks in the workflow',\n        },\n        savePath: {\n          type: 'string',\n          description: 'Path to save the workflow file',\n        },\n      },\n      required: ['name', 'tasks'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflow = {\n        name: input.name,\n        description: input.description,\n        tasks: input.tasks,\n        created: new Date().toISOString(),\n      };\n\n      const result = await context.orchestrator.createWorkflow(workflow, input.savePath);\n\n      return {\n        ...result,\n        workflow,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListWorkflowsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/list',\n    description: 'List available workflows',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'Directory to search for workflows',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing workflows', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflows = await context.orchestrator.listWorkflows(input.directory);\n\n      return {\n        workflows,\n        count: workflows.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteCommandTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/execute',\n    description: 'Execute a command in a terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute',\n        },\n        args: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Command arguments',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the command',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        timeout: {\n          type: 'number',\n          default: 30000,\n          description: 'Command timeout in milliseconds',\n        },\n        terminalId: {\n          type: 'string',\n          description: 'Specific terminal ID to use',\n        },\n      },\n      required: ['command'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing command', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.executeCommand({\n        command: input.command,\n        args: input.args,\n        cwd: input.cwd,\n        env: input.env,\n        timeout: input.timeout || 30000,\n        terminalId: input.terminalId,\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTerminalsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/list',\n    description: 'List all terminal sessions',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeIdle: {\n          type: 'boolean',\n          default: true,\n          description: 'Include idle terminals',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing terminals', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminals = await context.orchestrator.listTerminals(input.includeIdle !== false);\n\n      return {\n        terminals,\n        count: terminals.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTerminalTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/create',\n    description: 'Create a new terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the terminal',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        shell: {\n          type: 'string',\n          description: 'Shell to use (bash, zsh, etc.)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating terminal', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminal = await context.orchestrator.createTerminal({\n        cwd: input.cwd,\n        env: input.env,\n        shell: input.shell,\n      });\n\n      return {\n        terminal,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction getDefaultSystemPrompt(type: string): string {\n  const prompts = {\n    coordinator:\n      'You are a coordinator agent responsible for planning, delegating, and orchestrating tasks across multiple agents.',\n    researcher:\n      'You are a research agent specialized in gathering, analyzing, and synthesizing information from various sources.',\n    implementer:\n      'You are an implementation agent focused on writing code, creating solutions, and executing technical tasks.',\n    analyst:\n      'You are an analysis agent that identifies patterns, generates insights, and provides data-driven recommendations.',\n    custom: 'You are a specialized agent with custom capabilities defined by your configuration.',\n  };\n\n  return prompts[type as keyof typeof prompts] || prompts.custom;\n}\n"],"names":["getAvailableAgentTypes","enhanceToolWithAgentTypes","tool","availableTypes","enhancedTool","JSON","parse","stringify","addEnumToAgentTypeFields","obj","key","value","Object","entries","field","type","description","includes","enum","inputSchema","createClaudeFlowTools","logger","tools","createSpawnAgentTool","createListAgentsTool","createTerminateAgentTool","createGetAgentInfoTool","createCreateTaskTool","createListTasksTool","createGetTaskStatusTool","createCancelTaskTool","createAssignTaskTool","createQueryMemoryTool","createStoreMemoryTool","createDeleteMemoryTool","createExportMemoryTool","createImportMemoryTool","createGetSystemStatusTool","createGetMetricsTool","createHealthCheckTool","createGetConfigTool","createUpdateConfigTool","createValidateConfigTool","createExecuteWorkflowTool","createCreateWorkflowTool","createListWorkflowsTool","createExecuteCommandTool","createListTerminalsTool","createCreateTerminalTool","enhancedTools","Promise","all","map","name","properties","capabilities","items","systemPrompt","maxConcurrentTasks","default","priority","environment","workingDirectory","required","handler","input","context","info","sessionId","orchestrator","Error","profile","id","Date","now","Math","random","toString","substr","getDefaultSystemPrompt","spawnAgent","agentId","status","timestamp","toISOString","includeTerminated","filterByType","agents","listAgents","filteredAgents","filter","agent","count","length","reason","graceful","terminateAgent","agentInfo","getAgentInfo","dependencies","assignToAgent","assignToAgentType","timeout","task","createdAt","taskId","createTask","assignTask","assignTaskToType","limit","offset","tasks","listTasks","getTask","cancelTask","tags","search","startTime","format","endTime","query","undefined","queryMemory","content","parentId","entry","version","entryId","storeMemory","deleteMemory","exportResult","exportMemory","filePath","mergeStrategy","importResult","importMemory","getSystemStatus","timeRange","metrics","getMetrics","deep","healthCheck","performHealthCheck","section","config","getConfig","restart","result","updateConfig","validation","validateConfig","workflow","parameters","executeWorkflow","assignTo","savePath","created","createWorkflow","directory","workflows","listWorkflows","command","args","cwd","env","terminalId","executeCommand","includeIdle","terminals","listTerminals","shell","terminal","createTerminal","prompts","coordinator","researcher","implementer","analyst","custom"],"mappings":"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"}