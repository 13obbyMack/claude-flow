{"version":3,"sources":["../../../../src/cli/simple-commands/hooks.js"],"sourcesContent":["import {\n  printSuccess,\n  printError,\n  printWarning,\n  execRuvSwarmHook,\n  checkRuvSwarmAvailable,\n} from '../utils.js';\nimport { SqliteMemoryStore } from '../../memory/sqlite-store.js';\n\n// Initialize memory store\nlet memoryStore = null;\n\nasync function getMemoryStore() {\n  if (!memoryStore) {\n    memoryStore = new SqliteMemoryStore();\n    await memoryStore.initialize();\n  }\n  return memoryStore;\n}\n\n// Simple ID generator\nfunction generateId(prefix = 'id') {\n  return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport async function hooksAction(subArgs, flags) {\n  const subcommand = subArgs[0];\n  const options = flags;\n\n  if (options.help || options.h || !subcommand) {\n    showHooksHelp();\n    return;\n  }\n\n  try {\n    switch (subcommand) {\n      // Pre-Operation Hooks\n      case 'pre-task':\n        await preTaskCommand(subArgs, flags);\n        break;\n      case 'pre-edit':\n        await preEditCommand(subArgs, flags);\n        break;\n      case 'pre-bash':\n      case 'pre-command': // Support both names for compatibility\n        await preBashCommand(subArgs, flags);\n        break;\n\n      // Post-Operation Hooks\n      case 'post-task':\n        await postTaskCommand(subArgs, flags);\n        break;\n      case 'post-edit':\n        await postEditCommand(subArgs, flags);\n        break;\n      case 'post-bash':\n      case 'post-command': // Support both names for compatibility\n        await postBashCommand(subArgs, flags);\n        break;\n      case 'post-search':\n        await postSearchCommand(subArgs, flags);\n        break;\n\n      // MCP Integration Hooks\n      case 'mcp-initialized':\n        await mcpInitializedCommand(subArgs, flags);\n        break;\n      case 'agent-spawned':\n        await agentSpawnedCommand(subArgs, flags);\n        break;\n      case 'task-orchestrated':\n        await taskOrchestratedCommand(subArgs, flags);\n        break;\n      case 'neural-trained':\n        await neuralTrainedCommand(subArgs, flags);\n        break;\n\n      // Session Hooks\n      case 'session-end':\n        await sessionEndCommand(subArgs, flags);\n        break;\n      case 'session-restore':\n        await sessionRestoreCommand(subArgs, flags);\n        break;\n      case 'notify':\n        await notifyCommand(subArgs, flags);\n        break;\n\n      default:\n        printError(`Unknown hooks command: ${subcommand}`);\n        showHooksHelp();\n    }\n  } catch (err) {\n    printError(`Hooks command failed: ${err.message}`);\n  }\n}\n\n// ===== PRE-OPERATION HOOKS =====\n\nasync function preTaskCommand(subArgs, flags) {\n  const options = flags;\n  const description = options.description || 'Unnamed task';\n  const taskId = options['task-id'] || options.taskId || generateId('task');\n  const agentId = options['agent-id'] || options.agentId;\n  const autoSpawnAgents = options['auto-spawn-agents'] !== 'false';\n\n  console.log(`üîÑ Executing pre-task hook...`);\n  console.log(`üìã Task: ${description}`);\n  console.log(`üÜî Task ID: ${taskId}`);\n  if (agentId) console.log(`ü§ñ Agent: ${agentId}`);\n\n  try {\n    const store = await getMemoryStore();\n    const taskData = {\n      taskId,\n      description,\n      agentId,\n      autoSpawnAgents,\n      status: 'started',\n      startedAt: new Date().toISOString(),\n    };\n\n    await store.store(`task:${taskId}`, taskData, {\n      namespace: 'hooks:pre-task',\n      metadata: { hookType: 'pre-task', agentId },\n    });\n\n    await store.store(\n      `task-index:${Date.now()}`,\n      {\n        taskId,\n        description,\n        timestamp: new Date().toISOString(),\n      },\n      { namespace: 'task-index' },\n    );\n\n    console.log(`  üíæ Saved to .swarm/memory.db`);\n\n    // Execute ruv-swarm hook if available (with timeout for npx scenarios)\n    try {\n      const checkPromise = checkRuvSwarmAvailable();\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Timeout')), 3000)\n      );\n      \n      const isAvailable = await Promise.race([checkPromise, timeoutPromise]);\n      \n      if (isAvailable) {\n        console.log(`\\nüîÑ Executing ruv-swarm pre-task hook...`);\n        const hookResult = await execRuvSwarmHook('pre-task', {\n          description,\n          'task-id': taskId,\n          'auto-spawn-agents': autoSpawnAgents,\n          ...(agentId ? { 'agent-id': agentId } : {}),\n        });\n\n        if (hookResult.success) {\n          await store.store(\n            `task:${taskId}:ruv-output`,\n            {\n              output: hookResult.output,\n              timestamp: new Date().toISOString(),\n            },\n            { namespace: 'hooks:ruv-swarm' },\n          );\n\n          printSuccess(`‚úÖ Pre-task hook completed successfully`);\n        }\n      }\n    } catch (err) {\n      // Skip ruv-swarm hook if it times out or fails\n      console.log(`\\n‚ö†Ô∏è  Skipping ruv-swarm hook (${err.message})`);\n    }\n\n    console.log(`\\nüéØ TASK PREPARATION COMPLETE`);\n    \n    // Close the memory store to prevent hanging\n    if (memoryStore && memoryStore.close) {\n      memoryStore.close();\n    }\n    \n    // Force exit after a short delay to ensure cleanup\n    setTimeout(() => {\n      process.exit(0);\n    }, 100);\n  } catch (err) {\n    printError(`Pre-task hook failed: ${err.message}`);\n    \n    // Close the memory store on error too\n    if (memoryStore && memoryStore.close) {\n      memoryStore.close();\n    }\n    \n    // Force exit after a short delay to ensure cleanup\n    setTimeout(() => {\n      process.exit(1);\n    }, 100);\n  }\n}\n\nasync function preEditCommand(subArgs, flags) {\n  const options = flags;\n  const file = options.file || 'unknown-file';\n  const operation = options.operation || 'edit';\n  const autoAssignAgents = options['auto-assign-agents'] || false;\n  const loadContext = options['load-context'] || false;\n\n  console.log(`üìù Executing pre-edit hook...`);\n  console.log(`üìÑ File: ${file}`);\n  console.log(`‚öôÔ∏è  Operation: ${operation}`);\n  if (autoAssignAgents) console.log(`ü§ñ Auto-assign agents: ENABLED`);\n  if (loadContext) console.log(`üîÑ Load context: ENABLED`);\n\n  try {\n    const store = await getMemoryStore();\n\n    // Auto-assign agents based on file type\n    let assignedAgentType = 'general';\n    let recommendedAgent = null;\n\n    if (autoAssignAgents) {\n      const path = await import('path');\n      const ext = path.extname(file).toLowerCase();\n\n      const agentMapping = {\n        '.js': 'javascript-developer',\n        '.ts': 'typescript-developer',\n        '.py': 'python-developer',\n        '.go': 'golang-developer',\n        '.rs': 'rust-developer',\n        '.java': 'java-developer',\n        '.cpp': 'cpp-developer',\n        '.c': 'c-developer',\n        '.css': 'frontend-developer',\n        '.html': 'frontend-developer',\n        '.vue': 'frontend-developer',\n        '.react': 'frontend-developer',\n        '.md': 'technical-writer',\n        '.yml': 'devops-engineer',\n        '.yaml': 'devops-engineer',\n        '.json': 'config-specialist',\n        '.sql': 'database-expert',\n        '.sh': 'system-admin',\n        '.dockerfile': 'devops-engineer',\n      };\n\n      assignedAgentType = agentMapping[ext] || 'general-developer';\n      recommendedAgent = {\n        type: assignedAgentType,\n        file: file,\n        extension: ext,\n        recommended: true,\n      };\n\n      console.log(`  ü§ñ Recommended agent: ${assignedAgentType}`);\n    }\n\n    // Load context if requested\n    let contextData = null;\n    if (loadContext) {\n      try {\n        // Check if file exists and get basic info\n        const fs = await import('fs');\n        const path = await import('path');\n\n        if (fs.existsSync(file)) {\n          const stats = fs.statSync(file);\n          const dirname = path.dirname(file);\n          const basename = path.basename(file);\n\n          contextData = {\n            fileExists: true,\n            size: stats.size,\n            modified: stats.mtime,\n            directory: dirname,\n            filename: basename,\n            isDirectory: stats.isDirectory(),\n          };\n\n          console.log(`  üìÅ Context loaded: ${basename} (${stats.size} bytes)`);\n        } else {\n          contextData = {\n            fileExists: false,\n            willCreate: true,\n            directory: path.dirname(file),\n            filename: path.basename(file),\n          };\n          console.log(`  üìÅ Context: New file will be created`);\n        }\n      } catch (err) {\n        console.log(`  ‚ö†Ô∏è  Warning: Could not load context for ${file}`);\n        contextData = { error: err.message };\n      }\n    }\n\n    const editData = {\n      file,\n      operation,\n      timestamp: new Date().toISOString(),\n      editId: generateId('edit'),\n      autoAssignAgents,\n      loadContext,\n      assignedAgentType,\n      recommendedAgent,\n      contextData,\n    };\n\n    await store.store(`edit:${editData.editId}:pre`, editData, {\n      namespace: 'hooks:pre-edit',\n      metadata: { hookType: 'pre-edit', file, agentType: assignedAgentType },\n    });\n\n    // Store agent recommendation if enabled\n    if (autoAssignAgents && recommendedAgent) {\n      await store.store(`agent-recommendation:${file}`, recommendedAgent, {\n        namespace: 'agent-assignments',\n        ttl: 3600, // 1 hour\n      });\n    }\n\n    console.log(`  üíæ Pre-edit state saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Pre-edit hook completed`);\n  } catch (err) {\n    printError(`Pre-edit hook failed: ${err.message}`);\n  }\n}\n\nasync function preBashCommand(subArgs, flags) {\n  const options = flags;\n  const command = options.command || subArgs.slice(1).join(' ') || '';\n  const workingDir = options.cwd || process.cwd();\n  const validateSafety = options['validate-safety'] === true || options['validate-safety'] === 'true' || options.validate === true || options.validate === 'true' || false;\n  const prepareResources = options['prepare-resources'] === true || options['prepare-resources'] === 'true' || false;\n\n  console.log(`üîß Executing pre-bash hook...`);\n  console.log(`üìú Command: ${command}`);\n  console.log(`üìÅ Working dir: ${workingDir}`);\n  if (validateSafety) console.log(`üîí Safety validation: ENABLED`);\n  if (prepareResources) console.log(`üõ†Ô∏è  Resource preparation: ENABLED`);\n\n  try {\n    const store = await getMemoryStore();\n    let safetyResult = 'skipped';\n\n    if (validateSafety) {\n      // Basic safety validation\n      const dangerousCommands = [\n        'rm -rf /',\n        'rm -rf .',\n        'rm -rf *',\n        'format',\n        'fdisk',\n        'mkfs',\n        'curl * | bash',\n        'wget * | sh',\n        'eval',\n        'exec',\n        'chmod 777',\n      ];\n\n      const isDangerous = command && typeof command === 'string' && command.length > 0 \n        ? dangerousCommands.some((dangerous) =>\n            command.toLowerCase().includes(dangerous.toLowerCase()),\n          )\n        : false;\n\n      safetyResult = isDangerous ? 'dangerous' : 'safe';\n\n      if (isDangerous) {\n        console.log(`  ‚ö†Ô∏è  Safety check: DANGEROUS COMMAND DETECTED`);\n        console.log(`  üö´ Command blocked for safety`);\n        printError(`Command blocked due to safety validation: ${command}`);\n        return;\n      }\n    }\n\n    if (prepareResources) {\n      // Resource preparation - create working directory if needed\n      const fs = await import('fs');\n      const path = await import('path');\n\n      if (!fs.existsSync(workingDir)) {\n        fs.mkdirSync(workingDir, { recursive: true });\n        console.log(`  üìÅ Created working directory: ${workingDir}`);\n      }\n\n      // Check available disk space\n      try {\n        const stats = fs.statSync(workingDir);\n        console.log(`  üíæ Working directory prepared`);\n      } catch (err) {\n        console.log(`  ‚ö†Ô∏è  Warning: Could not check working directory`);\n      }\n    }\n\n    const bashData = {\n      command,\n      workingDir,\n      timestamp: new Date().toISOString(),\n      bashId: generateId('bash'),\n      safety: safetyResult,\n      validationEnabled: validateSafety,\n      resourcesPrepped: prepareResources,\n    };\n\n    await store.store(`bash:${bashData.bashId}:pre`, bashData, {\n      namespace: 'hooks:pre-bash',\n      metadata: { hookType: 'pre-bash', command, safety: safetyResult },\n    });\n\n    console.log(`  üíæ Command logged to .swarm/memory.db`);\n    console.log(`  üîí Safety check: ${safetyResult.toUpperCase()}`);\n    printSuccess(`‚úÖ Pre-bash hook completed`);\n  } catch (err) {\n    printError(`Pre-bash hook failed: ${err.message}`);\n  }\n}\n\n// ===== POST-OPERATION HOOKS =====\n\nasync function postTaskCommand(subArgs, flags) {\n  const options = flags;\n  const taskId = options['task-id'] || options.taskId || generateId('task');\n  const analyzePerformance = options['analyze-performance'] !== 'false';\n\n  console.log(`üèÅ Executing post-task hook...`);\n  console.log(`üÜî Task ID: ${taskId}`);\n\n  try {\n    const store = await getMemoryStore();\n    const taskData = await store.retrieve(`task:${taskId}`, {\n      namespace: 'hooks:pre-task',\n    });\n\n    const completedData = {\n      ...(taskData || {}),\n      status: 'completed',\n      completedAt: new Date().toISOString(),\n      duration: taskData ? Date.now() - new Date(taskData.startedAt).getTime() : null,\n    };\n\n    await store.store(`task:${taskId}:completed`, completedData, {\n      namespace: 'hooks:post-task',\n      metadata: { hookType: 'post-task' },\n    });\n\n    if (analyzePerformance && completedData.duration) {\n      const metrics = {\n        taskId,\n        duration: completedData.duration,\n        durationHuman: `${(completedData.duration / 1000).toFixed(2)}s`,\n        timestamp: new Date().toISOString(),\n      };\n\n      await store.store(`metrics:${taskId}`, metrics, {\n        namespace: 'performance',\n      });\n      console.log(`  üìä Performance: ${metrics.durationHuman}`);\n    }\n\n    console.log(`  üíæ Task completion saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Post-task hook completed`);\n  } catch (err) {\n    printError(`Post-task hook failed: ${err.message}`);\n  }\n}\n\nasync function postEditCommand(subArgs, flags) {\n  const options = flags;\n  const file = options.file || 'unknown-file';\n  let memoryKey = options['memory-key'] || options.memoryKey;\n  \n  // Handle case where memory-key is passed as a boolean flag without value\n  if (memoryKey === true) {\n    // Generate a default memory key based on the file path and timestamp\n    const path = await import('path');\n    const basename = path.basename(file);\n    memoryKey = `edit:${basename}:${Date.now()}`;\n  }\n  \n  const format = options.format || false;\n  const updateMemory = options['update-memory'] || false;\n  const trainNeural = options['train-neural'] || false;\n\n  console.log(`üìù Executing post-edit hook...`);\n  console.log(`üìÑ File: ${file}`);\n  if (memoryKey) console.log(`üíæ Memory key: ${memoryKey}`);\n  if (format) console.log(`üé® Auto-format: ENABLED`);\n  if (updateMemory) console.log(`üß† Memory update: ENABLED`);\n  if (trainNeural) console.log(`ü§ñ Neural training: ENABLED`);\n\n  try {\n    const store = await getMemoryStore();\n    const path = await import('path');\n    const fs = await import('fs');\n\n    // Auto-format file if requested\n    let formatResult = null;\n    if (format && fs.existsSync(file)) {\n      const ext = path.extname(file).toLowerCase();\n      const formatters = {\n        '.js': 'prettier',\n        '.ts': 'prettier',\n        '.json': 'prettier',\n        '.css': 'prettier',\n        '.html': 'prettier',\n        '.py': 'black',\n        '.go': 'gofmt',\n        '.rs': 'rustfmt',\n        '.java': 'google-java-format',\n        '.cpp': 'clang-format',\n        '.c': 'clang-format',\n      };\n\n      const formatter = formatters[ext];\n      if (formatter) {\n        console.log(`  üé® Auto-formatting with ${formatter}...`);\n        formatResult = {\n          formatter,\n          extension: ext,\n          attempted: true,\n          timestamp: new Date().toISOString(),\n        };\n      } else {\n        console.log(`  ‚ö†Ô∏è  No formatter available for ${ext}`);\n        formatResult = {\n          extension: ext,\n          attempted: false,\n          reason: 'No formatter available',\n        };\n      }\n    }\n\n    // Update memory with edit context\n    let memoryUpdate = null;\n    if (updateMemory) {\n      const editContext = {\n        file,\n        editedAt: new Date().toISOString(),\n        editId: generateId('edit'),\n        formatted: formatResult?.attempted || false,\n        fileSize: fs.existsSync(file) ? fs.statSync(file).size : 0,\n        directory: path.dirname(file),\n        basename: path.basename(file),\n      };\n\n      memoryUpdate = editContext;\n\n      // Store in coordination namespace\n      await store.store(`edit-context:${editContext.editId}`, editContext, {\n        namespace: 'coordination',\n        metadata: { type: 'edit-context', file },\n      });\n\n      console.log(`  üß† Edit context stored in memory`);\n    }\n\n    // Train neural patterns if requested\n    let neuralTraining = null;\n    if (trainNeural) {\n      // Simulate neural training with file patterns\n      const ext = path.extname(file).toLowerCase();\n      const basename = path.basename(file);\n      const editTime = new Date().toISOString();\n\n      const patterns = {\n        fileType: ext,\n        fileName: basename,\n        editTime,\n        confidence: Math.random() * 0.5 + 0.5, // 50-100% confidence\n        patterns: [\n          `${ext}_edit_pattern`,\n          `${basename}_modification`,\n          `edit_${Date.now()}_sequence`,\n        ],\n      };\n\n      neuralTraining = patterns;\n\n      await store.store(`neural-pattern:${generateId('pattern')}`, patterns, {\n        namespace: 'neural-training',\n        metadata: { type: 'edit-pattern', file, extension: ext },\n      });\n\n      console.log(\n        `  ü§ñ Neural patterns trained (${(patterns.confidence * 100).toFixed(1)}% confidence)`,\n      );\n    }\n\n    const editData = {\n      file,\n      memoryKey,\n      timestamp: new Date().toISOString(),\n      editId: generateId('edit'),\n      format,\n      updateMemory,\n      trainNeural,\n      formatResult,\n      memoryUpdate,\n      neuralTraining,\n    };\n\n    await store.store(`edit:${editData.editId}:post`, editData, {\n      namespace: 'hooks:post-edit',\n      metadata: { hookType: 'post-edit', file, formatted: formatResult?.attempted || false },\n    });\n\n    if (memoryKey && typeof memoryKey === 'string') {\n      await store.store(\n        memoryKey,\n        {\n          file,\n          editedAt: new Date().toISOString(),\n          editId: editData.editId,\n          enhanced: true,\n          formatResult,\n          memoryUpdate,\n          neuralTraining,\n        },\n        { namespace: 'coordination' },\n      );\n    }\n\n    const historyKey = `file-history:${file.replace(/\\//g, '_')}:${Date.now()}`;\n    await store.store(\n      historyKey,\n      {\n        file,\n        editId: editData.editId,\n        timestamp: new Date().toISOString(),\n        enhanced: true,\n        features: {\n          format,\n          updateMemory,\n          trainNeural,\n        },\n      },\n      { namespace: 'file-history' },\n    );\n\n    console.log(`  üíæ Post-edit data saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Post-edit hook completed`);\n  } catch (err) {\n    printError(`Post-edit hook failed: ${err.message}`);\n  }\n}\n\nasync function postBashCommand(subArgs, flags) {\n  const options = flags;\n  const command = options.command || subArgs.slice(1).join(' ');\n  const exitCode = options['exit-code'] || '0';\n  const output = options.output || '';\n  const trackMetrics = options['track-metrics'] || false;\n  const storeResults = options['store-results'] || false;\n  const duration = options.duration || 0;\n\n  console.log(`üîß Executing post-bash hook...`);\n  console.log(`üìú Command: ${command}`);\n  console.log(`üìä Exit code: ${exitCode}`);\n  if (trackMetrics) console.log(`üìä Metrics tracking: ENABLED`);\n  if (storeResults) console.log(`üíæ Results storage: ENABLED`);\n\n  try {\n    const store = await getMemoryStore();\n    const startTime = Date.now();\n\n    // Calculate performance metrics if enabled\n    let metrics = null;\n    if (trackMetrics) {\n      const commandLength = command.length;\n      const outputLength = output.length;\n      const success = parseInt(exitCode) === 0;\n\n      metrics = {\n        commandLength,\n        outputLength,\n        success,\n        duration: parseInt(duration) || 0,\n        exitCode: parseInt(exitCode),\n        timestamp: new Date().toISOString(),\n        complexity: commandLength > 100 ? 'high' : commandLength > 50 ? 'medium' : 'low',\n      };\n\n      console.log(\n        `  üìä Command metrics: ${commandLength} chars, ${outputLength} output, ${success ? 'SUCCESS' : 'FAILED'}`,\n      );\n    }\n\n    const bashData = {\n      command,\n      exitCode,\n      output: storeResults ? output.substring(0, 5000) : output.substring(0, 1000), // Store more if requested\n      timestamp: new Date().toISOString(),\n      bashId: generateId('bash'),\n      trackMetrics,\n      storeResults,\n      metrics,\n    };\n\n    await store.store(`bash:${bashData.bashId}:post`, bashData, {\n      namespace: 'hooks:post-bash',\n      metadata: { hookType: 'post-bash', command, exitCode, success: parseInt(exitCode) === 0 },\n    });\n\n    // Store detailed results if enabled\n    if (storeResults) {\n      await store.store(\n        `command-results:${bashData.bashId}`,\n        {\n          command,\n          exitCode,\n          output,\n          timestamp: new Date().toISOString(),\n          fullOutput: true,\n        },\n        { namespace: 'command-results' },\n      );\n\n      console.log(`  üíæ Full command results stored`);\n    }\n\n    // Store metrics if enabled\n    if (trackMetrics && metrics) {\n      await store.store(`command-metrics:${bashData.bashId}`, metrics, {\n        namespace: 'performance-metrics',\n      });\n\n      // Update running metrics\n      const existingMetrics = (await store.retrieve('command-metrics-summary', {\n        namespace: 'performance-metrics',\n      })) || { totalCommands: 0, successRate: 0, avgDuration: 0 };\n\n      existingMetrics.totalCommands += 1;\n      existingMetrics.successRate =\n        (existingMetrics.successRate * (existingMetrics.totalCommands - 1) +\n          (metrics.success ? 1 : 0)) /\n        existingMetrics.totalCommands;\n      existingMetrics.avgDuration =\n        (existingMetrics.avgDuration * (existingMetrics.totalCommands - 1) + metrics.duration) /\n        existingMetrics.totalCommands;\n      existingMetrics.lastUpdated = new Date().toISOString();\n\n      await store.store('command-metrics-summary', existingMetrics, {\n        namespace: 'performance-metrics',\n      });\n    }\n\n    // Update command history\n    await store.store(\n      `command-history:${Date.now()}`,\n      {\n        command,\n        exitCode,\n        timestamp: new Date().toISOString(),\n        success: parseInt(exitCode) === 0,\n        hasMetrics: trackMetrics,\n        hasResults: storeResults,\n      },\n      { namespace: 'command-history' },\n    );\n\n    console.log(`  üíæ Command execution logged to .swarm/memory.db`);\n    printSuccess(`‚úÖ Post-bash hook completed`);\n  } catch (err) {\n    printError(`Post-bash hook failed: ${err.message}`);\n  }\n}\n\nasync function postSearchCommand(subArgs, flags) {\n  const options = flags;\n  const query = options.query || subArgs.slice(1).join(' ');\n  const resultCount = options['result-count'] || '0';\n  const searchType = options.type || 'general';\n\n  console.log(`üîç Executing post-search hook...`);\n  console.log(`üîé Query: ${query}`);\n  console.log(`üìä Results: ${resultCount}`);\n\n  try {\n    const store = await getMemoryStore();\n    const searchData = {\n      query,\n      resultCount: parseInt(resultCount),\n      searchType,\n      timestamp: new Date().toISOString(),\n      searchId: generateId('search'),\n    };\n\n    await store.store(`search:${searchData.searchId}`, searchData, {\n      namespace: 'hooks:post-search',\n      metadata: { hookType: 'post-search', query },\n    });\n\n    // Cache search for future use\n    await store.store(\n      `search-cache:${query}`,\n      {\n        resultCount: searchData.resultCount,\n        cachedAt: new Date().toISOString(),\n      },\n      { namespace: 'search-cache', ttl: 3600 },\n    ); // 1 hour TTL\n\n    console.log(`  üíæ Search results cached to .swarm/memory.db`);\n    printSuccess(`‚úÖ Post-search hook completed`);\n  } catch (err) {\n    printError(`Post-search hook failed: ${err.message}`);\n  }\n}\n\n// ===== MCP INTEGRATION HOOKS =====\n\nasync function mcpInitializedCommand(subArgs, flags) {\n  const options = flags;\n  const serverName = options.server || 'claude-flow';\n  const sessionId = options['session-id'] || generateId('mcp-session');\n\n  console.log(`üîå Executing mcp-initialized hook...`);\n  console.log(`üíª Server: ${serverName}`);\n  console.log(`üÜî Session: ${sessionId}`);\n\n  try {\n    const store = await getMemoryStore();\n    const mcpData = {\n      serverName,\n      sessionId,\n      initializedAt: new Date().toISOString(),\n      status: 'active',\n    };\n\n    await store.store(`mcp:${sessionId}`, mcpData, {\n      namespace: 'hooks:mcp-initialized',\n      metadata: { hookType: 'mcp-initialized', server: serverName },\n    });\n\n    console.log(`  üíæ MCP session saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ MCP initialized hook completed`);\n  } catch (err) {\n    printError(`MCP initialized hook failed: ${err.message}`);\n  }\n}\n\nasync function agentSpawnedCommand(subArgs, flags) {\n  const options = flags;\n  const agentType = options.type || 'generic';\n  const agentName = options.name || generateId('agent');\n  const swarmId = options['swarm-id'] || 'default';\n\n  console.log(`ü§ñ Executing agent-spawned hook...`);\n  console.log(`üìõ Agent: ${agentName}`);\n  console.log(`üè∑Ô∏è  Type: ${agentType}`);\n\n  try {\n    const store = await getMemoryStore();\n    const agentData = {\n      agentName,\n      agentType,\n      swarmId,\n      spawnedAt: new Date().toISOString(),\n      status: 'active',\n    };\n\n    await store.store(`agent:${agentName}`, agentData, {\n      namespace: 'hooks:agent-spawned',\n      metadata: { hookType: 'agent-spawned', type: agentType },\n    });\n\n    // Update agent roster\n    await store.store(\n      `agent-roster:${Date.now()}`,\n      {\n        agentName,\n        action: 'spawned',\n        timestamp: new Date().toISOString(),\n      },\n      { namespace: 'agent-roster' },\n    );\n\n    console.log(`  üíæ Agent registered to .swarm/memory.db`);\n    printSuccess(`‚úÖ Agent spawned hook completed`);\n  } catch (err) {\n    printError(`Agent spawned hook failed: ${err.message}`);\n  }\n}\n\nasync function taskOrchestratedCommand(subArgs, flags) {\n  const options = flags;\n  const taskId = options['task-id'] || generateId('orchestrated-task');\n  const strategy = options.strategy || 'balanced';\n  const priority = options.priority || 'medium';\n\n  console.log(`üé≠ Executing task-orchestrated hook...`);\n  console.log(`üÜî Task: ${taskId}`);\n  console.log(`üìä Strategy: ${strategy}`);\n\n  try {\n    const store = await getMemoryStore();\n    const orchestrationData = {\n      taskId,\n      strategy,\n      priority,\n      orchestratedAt: new Date().toISOString(),\n      status: 'orchestrated',\n    };\n\n    await store.store(`orchestration:${taskId}`, orchestrationData, {\n      namespace: 'hooks:task-orchestrated',\n      metadata: { hookType: 'task-orchestrated', strategy },\n    });\n\n    console.log(`  üíæ Orchestration saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Task orchestrated hook completed`);\n  } catch (err) {\n    printError(`Task orchestrated hook failed: ${err.message}`);\n  }\n}\n\nasync function neuralTrainedCommand(subArgs, flags) {\n  const options = flags;\n  const modelName = options.model || 'default-neural';\n  const accuracy = options.accuracy || '0.0';\n  const patterns = options.patterns || '0';\n\n  console.log(`üß† Executing neural-trained hook...`);\n  console.log(`ü§ñ Model: ${modelName}`);\n  console.log(`üìä Accuracy: ${accuracy}%`);\n\n  try {\n    const store = await getMemoryStore();\n    const trainingData = {\n      modelName,\n      accuracy: parseFloat(accuracy),\n      patternsLearned: parseInt(patterns),\n      trainedAt: new Date().toISOString(),\n    };\n\n    await store.store(`neural:${modelName}:${Date.now()}`, trainingData, {\n      namespace: 'hooks:neural-trained',\n      metadata: { hookType: 'neural-trained', model: modelName },\n    });\n\n    console.log(`  üíæ Training results saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Neural trained hook completed`);\n  } catch (err) {\n    printError(`Neural trained hook failed: ${err.message}`);\n  }\n}\n\n// ===== SESSION HOOKS =====\n\nasync function sessionEndCommand(subArgs, flags) {\n  const options = flags;\n  const generateSummary = options['generate-summary'] !== 'false';\n  const persistState = options['persist-state'] !== 'false';\n  const exportMetrics = options['export-metrics'] || false;\n\n  console.log(`üîö Executing session-end hook...`);\n  if (generateSummary) console.log(`üìä Summary generation: ENABLED`);\n  if (persistState) console.log(`üíæ State persistence: ENABLED`);\n  if (exportMetrics) console.log(`üìà Metrics export: ENABLED`);\n\n  try {\n    const store = await getMemoryStore();\n    const tasks = await store.list({ namespace: 'task-index', limit: 1000 });\n    const edits = await store.list({ namespace: 'file-history', limit: 1000 });\n    const commands = await store.list({ namespace: 'command-history', limit: 1000 });\n    const agents = await store.list({ namespace: 'agent-roster', limit: 1000 });\n\n    // Calculate session metrics\n    let metrics = null;\n    if (exportMetrics) {\n      const now = new Date();\n      const sessionStart = Math.min(\n        ...tasks.map((t) => new Date(t.value.timestamp || now).getTime()),\n        ...edits.map((e) => new Date(e.value.timestamp || now).getTime()),\n        ...commands.map((c) => new Date(c.value.timestamp || now).getTime()),\n      );\n\n      const duration = now.getTime() - sessionStart;\n      const successfulCommands = commands.filter((c) => c.value.success !== false).length;\n      const commandSuccessRate = commands.length > 0 ? successfulCommands / commands.length : 1;\n\n      metrics = {\n        sessionDuration: duration,\n        sessionDurationHuman: `${Math.round(duration / 1000 / 60)} minutes`,\n        totalTasks: tasks.length,\n        totalEdits: edits.length,\n        totalCommands: commands.length,\n        uniqueAgents: agents.length,\n        commandSuccessRate: Math.round(commandSuccessRate * 100),\n        avgTasksPerMinute: Math.round((tasks.length / (duration / 1000 / 60)) * 100) / 100,\n        avgEditsPerMinute: Math.round((edits.length / (duration / 1000 / 60)) * 100) / 100,\n        timestamp: now.toISOString(),\n      };\n    }\n\n    const sessionData = {\n      endedAt: new Date().toISOString(),\n      totalTasks: tasks.length,\n      totalEdits: edits.length,\n      totalCommands: commands.length,\n      uniqueAgents: agents.length,\n      sessionId: generateId('session'),\n      generateSummary,\n      persistState,\n      exportMetrics,\n      metrics,\n    };\n\n    await store.store(`session:${sessionData.sessionId}`, sessionData, {\n      namespace: 'sessions',\n      metadata: { hookType: 'session-end' },\n    });\n\n    // Persist detailed state if requested\n    if (persistState) {\n      const detailedState = {\n        sessionId: sessionData.sessionId,\n        tasks: tasks.slice(0, 100), // Limit to prevent memory issues\n        edits: edits.slice(0, 100),\n        commands: commands.slice(0, 100),\n        agents: agents.slice(0, 50),\n        persistedAt: new Date().toISOString(),\n        fullState: true,\n      };\n\n      await store.store(`session-state:${sessionData.sessionId}`, detailedState, {\n        namespace: 'session-states',\n        metadata: { type: 'full-state', sessionId: sessionData.sessionId },\n      });\n\n      console.log(`  üíæ Full session state persisted`);\n    }\n\n    // Export metrics if requested\n    if (exportMetrics && metrics) {\n      await store.store(`session-metrics:${sessionData.sessionId}`, metrics, {\n        namespace: 'session-metrics',\n        metadata: { type: 'performance-metrics', sessionId: sessionData.sessionId },\n      });\n\n      console.log(`  üìà Session metrics exported`);\n    }\n\n    if (generateSummary) {\n      console.log(`\\nüìä SESSION SUMMARY:`);\n      console.log(`  üìã Tasks: ${sessionData.totalTasks}`);\n      console.log(`  ‚úèÔ∏è  Edits: ${sessionData.totalEdits}`);\n      console.log(`  üîß Commands: ${sessionData.totalCommands}`);\n      console.log(`  ü§ñ Agents: ${sessionData.uniqueAgents}`);\n\n      if (metrics) {\n        console.log(`  ‚è±Ô∏è  Duration: ${metrics.sessionDurationHuman}`);\n        console.log(`  üìà Success Rate: ${metrics.commandSuccessRate}%`);\n        console.log(`  üèÉ Tasks/min: ${metrics.avgTasksPerMinute}`);\n        console.log(`  ‚úèÔ∏è  Edits/min: ${metrics.avgEditsPerMinute}`);\n      }\n    }\n\n    console.log(`  üíæ Session saved to .swarm/memory.db`);\n\n    if (memoryStore) {\n      memoryStore.close();\n      memoryStore = null;\n    }\n\n    printSuccess(`‚úÖ Session-end hook completed`);\n  } catch (err) {\n    printError(`Session-end hook failed: ${err.message}`);\n  }\n}\n\nasync function sessionRestoreCommand(subArgs, flags) {\n  const options = flags;\n  const sessionId = options['session-id'] || 'latest';\n\n  console.log(`üîÑ Executing session-restore hook...`);\n  console.log(`üÜî Session: ${sessionId}`);\n\n  try {\n    const store = await getMemoryStore();\n\n    // Find session to restore\n    let sessionData;\n    if (sessionId === 'latest') {\n      const sessions = await store.list({ namespace: 'sessions', limit: 1 });\n      sessionData = sessions[0]?.value;\n    } else {\n      sessionData = await store.retrieve(`session:${sessionId}`, { namespace: 'sessions' });\n    }\n\n    if (sessionData) {\n      console.log(`\\nüìä RESTORED SESSION:`);\n      console.log(`  üÜî ID: ${sessionData.sessionId || 'unknown'}`);\n      console.log(`  üìã Tasks: ${sessionData.totalTasks || 0}`);\n      console.log(`  ‚úèÔ∏è  Edits: ${sessionData.totalEdits || 0}`);\n      console.log(`  ‚è∞ Ended: ${sessionData.endedAt || 'unknown'}`);\n\n      // Store restoration event\n      await store.store(\n        `session-restore:${Date.now()}`,\n        {\n          restoredSessionId: sessionData.sessionId || sessionId,\n          restoredAt: new Date().toISOString(),\n        },\n        { namespace: 'session-events' },\n      );\n\n      console.log(`  üíæ Session restored from .swarm/memory.db`);\n      printSuccess(`‚úÖ Session restore completed`);\n    } else {\n      printWarning(`No session found with ID: ${sessionId}`);\n    }\n  } catch (err) {\n    printError(`Session restore hook failed: ${err.message}`);\n  }\n}\n\nasync function notifyCommand(subArgs, flags) {\n  const options = flags;\n  const message = options.message || subArgs.slice(1).join(' ');\n  const level = options.level || 'info';\n  const swarmStatus = options['swarm-status'] || 'active';\n\n  console.log(`üì¢ Executing notify hook...`);\n  console.log(`üí¨ Message: ${message}`);\n  console.log(`üìä Level: ${level}`);\n\n  try {\n    const store = await getMemoryStore();\n    const notificationData = {\n      message,\n      level,\n      swarmStatus,\n      timestamp: new Date().toISOString(),\n      notifyId: generateId('notify'),\n    };\n\n    await store.store(`notification:${notificationData.notifyId}`, notificationData, {\n      namespace: 'hooks:notify',\n      metadata: { hookType: 'notify', level },\n    });\n\n    // Display notification\n    const icon = level === 'error' ? '‚ùå' : level === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';\n    console.log(`\\n${icon} NOTIFICATION:`);\n    console.log(`  ${message}`);\n    console.log(`  üêù Swarm: ${swarmStatus}`);\n\n    console.log(`\\n  üíæ Notification saved to .swarm/memory.db`);\n    printSuccess(`‚úÖ Notify hook completed`);\n  } catch (err) {\n    printError(`Notify hook failed: ${err.message}`);\n  }\n}\n\nfunction showHooksHelp() {\n  console.log('Claude Flow Hooks (with .swarm/memory.db persistence):\\n');\n\n  console.log('Pre-Operation Hooks:');\n  console.log('  pre-task        Execute before starting a task');\n  console.log('  pre-edit        Validate before file modifications');\n  console.log('                  --auto-assign-agents  Auto-assign agents based on file type');\n  console.log('                  --load-context        Load file context');\n  console.log('  pre-bash        Check command safety (alias: pre-command)');\n  console.log('  pre-command     Same as pre-bash');\n  console.log('                  --validate-safety     Enable safety validation');\n  console.log('                  --prepare-resources   Prepare execution resources');\n\n  console.log('\\nPost-Operation Hooks:');\n  console.log('  post-task       Execute after completing a task');\n  console.log('  post-edit       Auto-format and log edits');\n  console.log('                  --format              Auto-format code');\n  console.log('                  --update-memory       Update agent memory');\n  console.log('                  --train-neural        Train neural patterns');\n  console.log('  post-bash       Log command execution (alias: post-command)');\n  console.log('  post-command    Same as post-bash');\n  console.log('                  --track-metrics       Track performance metrics');\n  console.log('                  --store-results       Store detailed results');\n  console.log('  post-search     Cache search results');\n\n  console.log('\\nMCP Integration Hooks:');\n  console.log('  mcp-initialized    Persist MCP configuration');\n  console.log('  agent-spawned      Update agent roster');\n  console.log('  task-orchestrated  Monitor task progress');\n  console.log('  neural-trained     Save pattern improvements');\n\n  console.log('\\nSession Hooks:');\n  console.log('  session-end        Generate summary and save state');\n  console.log('                     --generate-summary    Generate session summary');\n  console.log('                     --persist-state       Persist session state');\n  console.log('                     --export-metrics      Export performance metrics');\n  console.log('  session-restore    Load previous session state');\n  console.log('  notify             Custom notifications');\n\n  console.log('\\nExamples:');\n  console.log('  hooks pre-command --command \"npm test\" --validate-safety true');\n  console.log('  hooks pre-edit --file \"src/app.js\" --auto-assign-agents true');\n  console.log('  hooks post-command --command \"build\" --track-metrics true');\n  console.log('  hooks post-edit --file \"src/app.js\" --format true --train-neural true');\n  console.log('  hooks session-end --generate-summary true --export-metrics true');\n  console.log('  hooks agent-spawned --name \"CodeReviewer\" --type \"reviewer\"');\n  console.log('  hooks notify --message \"Build completed\" --level \"success\"');\n\n  console.log('\\nCompatibility:');\n  console.log('  ‚Ä¢ pre-command and pre-bash are aliases');\n  console.log('  ‚Ä¢ post-command and post-bash are aliases');\n  console.log('  ‚Ä¢ Both --dash-case and camelCase parameters supported');\n  console.log('  ‚Ä¢ All parameters from settings.json template supported');\n}\n\nexport default hooksAction;\n"],"names":["printSuccess","printError","printWarning","execRuvSwarmHook","checkRuvSwarmAvailable","SqliteMemoryStore","memoryStore","getMemoryStore","initialize","generateId","prefix","Date","now","Math","random","toString","substr","hooksAction","subArgs","flags","subcommand","options","help","h","showHooksHelp","preTaskCommand","preEditCommand","preBashCommand","postTaskCommand","postEditCommand","postBashCommand","postSearchCommand","mcpInitializedCommand","agentSpawnedCommand","taskOrchestratedCommand","neuralTrainedCommand","sessionEndCommand","sessionRestoreCommand","notifyCommand","err","message","description","taskId","agentId","autoSpawnAgents","console","log","store","taskData","status","startedAt","toISOString","namespace","metadata","hookType","timestamp","checkPromise","timeoutPromise","Promise","_","reject","setTimeout","Error","isAvailable","race","hookResult","success","output","close","process","exit","file","operation","autoAssignAgents","loadContext","assignedAgentType","recommendedAgent","path","ext","extname","toLowerCase","agentMapping","type","extension","recommended","contextData","fs","existsSync","stats","statSync","dirname","basename","fileExists","size","modified","mtime","directory","filename","isDirectory","willCreate","error","editData","editId","agentType","ttl","command","slice","join","workingDir","cwd","validateSafety","validate","prepareResources","safetyResult","dangerousCommands","isDangerous","length","some","dangerous","includes","mkdirSync","recursive","bashData","bashId","safety","validationEnabled","resourcesPrepped","toUpperCase","analyzePerformance","retrieve","completedData","completedAt","duration","getTime","metrics","durationHuman","toFixed","memoryKey","format","updateMemory","trainNeural","formatResult","formatters","formatter","attempted","reason","memoryUpdate","editContext","editedAt","formatted","fileSize","neuralTraining","editTime","patterns","fileType","fileName","confidence","enhanced","historyKey","replace","features","exitCode","trackMetrics","storeResults","startTime","commandLength","outputLength","parseInt","complexity","substring","fullOutput","existingMetrics","totalCommands","successRate","avgDuration","lastUpdated","hasMetrics","hasResults","query","resultCount","searchType","searchData","searchId","cachedAt","serverName","server","sessionId","mcpData","initializedAt","agentName","name","swarmId","agentData","spawnedAt","action","strategy","priority","orchestrationData","orchestratedAt","modelName","model","accuracy","trainingData","parseFloat","patternsLearned","trainedAt","generateSummary","persistState","exportMetrics","tasks","list","limit","edits","commands","agents","sessionStart","min","map","t","value","e","c","successfulCommands","filter","commandSuccessRate","sessionDuration","sessionDurationHuman","round","totalTasks","totalEdits","uniqueAgents","avgTasksPerMinute","avgEditsPerMinute","sessionData","endedAt","detailedState","persistedAt","fullState","sessions","restoredSessionId","restoredAt","level","swarmStatus","notificationData","notifyId","icon"],"mappings":"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"}