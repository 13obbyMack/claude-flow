{"version":3,"sources":["../../../src/core/orchestrator.ts"],"sourcesContent":["/**\n * Main orchestrator for Claude-Flow\n */\n\nimport {\n  Config,\n  SystemEvents,\n  AgentProfile,\n  AgentSession,\n  Task,\n  HealthStatus,\n  ComponentHealth,\n  TaskStatus,\n  OrchestratorMetrics,\n} from '../utils/types.js';\nimport { IEventBus } from './event-bus.js';\nimport type { ILogger } from './logger.js';\nimport type { ITerminalManager } from '../terminal/manager.js';\nimport type { IMemoryManager } from '../memory/manager.js';\nimport type { ICoordinationManager } from '../coordination/manager.js';\nimport type { IMCPServer } from '../mcp/server.js';\nimport { SystemError, InitializationError, ShutdownError } from '../utils/errors.js';\nimport { delay, retry, circuitBreaker, CircuitBreaker } from '../utils/helpers.js';\nimport { mkdir, writeFile, readFile } from 'fs/promises';\nimport { join, dirname } from 'path';\nimport { ClaudeAPIClient } from '../api/claude-client.js';\nimport { ConfigManager } from '../config/config-manager.js';\n\nexport interface ISessionManager {\n  createSession(profile: AgentProfile): Promise<AgentSession>;\n  getSession(sessionId: string): AgentSession | undefined;\n  getActiveSessions(): AgentSession[];\n  terminateSession(sessionId: string): Promise<void>;\n  terminateAllSessions(): Promise<void>;\n  persistSessions(): Promise<void>;\n  restoreSessions(): Promise<void>;\n  removeSession(sessionId: string): void;\n}\n\nexport interface IOrchestrator {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  spawnAgent(profile: AgentProfile): Promise<string>;\n  terminateAgent(agentId: string): Promise<void>;\n  assignTask(task: Task): Promise<void>;\n  getHealthStatus(): Promise<HealthStatus>;\n  getMetrics(): Promise<OrchestratorMetrics>;\n  performMaintenance(): Promise<void>;\n}\n\nexport interface SessionPersistence {\n  sessions: Array<AgentSession & { profile: AgentProfile }>;\n  taskQueue: Task[];\n  metrics: {\n    completedTasks: number;\n    failedTasks: number;\n    totalTaskDuration: number;\n  };\n  savedAt: Date;\n}\n\n/**\n * Session manager implementation with persistence\n */\nclass SessionManager implements ISessionManager {\n  private sessions = new Map<string, AgentSession>();\n  private sessionProfiles = new Map<string, AgentProfile>();\n  private persistencePath: string;\n  private persistenceCircuitBreaker: CircuitBreaker;\n\n  constructor(\n    private terminalManager: ITerminalManager,\n    private memoryManager: IMemoryManager,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n    private config: Config,\n  ) {\n    this.persistencePath = join(config.orchestrator.dataDir || './data', 'sessions.json');\n\n    // Circuit breaker for persistence operations\n    this.persistenceCircuitBreaker = circuitBreaker('SessionPersistence', {\n      threshold: 5,\n      timeout: 30000,\n      resetTimeout: 60000,\n    });\n  }\n\n  async createSession(profile: AgentProfile): Promise<AgentSession> {\n    try {\n      // Create terminal with retry logic\n      const terminalId = await retry(() => this.terminalManager.spawnTerminal(profile), {\n        maxAttempts: 3,\n        initialDelay: 1000,\n      });\n\n      // Create memory bank with retry logic\n      const memoryBankId = await retry(() => this.memoryManager.createBank(profile.id), {\n        maxAttempts: 3,\n        initialDelay: 1000,\n      });\n\n      // Create session\n      const session: AgentSession = {\n        id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        agentId: profile.id,\n        terminalId,\n        startTime: new Date(),\n        status: 'active',\n        lastActivity: new Date(),\n        memoryBankId,\n      };\n\n      this.sessions.set(session.id, session);\n      this.sessionProfiles.set(session.id, profile);\n\n      this.logger.info('Session created', {\n        sessionId: session.id,\n        agentId: profile.id,\n        terminalId,\n        memoryBankId,\n      });\n\n      // Persist sessions asynchronously\n      this.persistSessions().catch((error) =>\n        this.logger.error('Failed to persist sessions', error),\n      );\n\n      return session;\n    } catch (error) {\n      this.logger.error('Failed to create session', { agentId: profile.id, error });\n      throw new SystemError(`Failed to create session for agent ${profile.id}`, { error });\n    }\n  }\n\n  getSession(sessionId: string): AgentSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  getActiveSessions(): AgentSession[] {\n    return Array.from(this.sessions.values()).filter(\n      (session) => session.status === 'active' || session.status === 'idle',\n    );\n  }\n\n  async terminateSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    try {\n      // Update session status first\n      session.status = 'terminated';\n      session.endTime = new Date();\n\n      // Terminate terminal with timeout\n      await Promise.race([\n        this.terminalManager.terminateTerminal(session.terminalId),\n        delay(5000).then(() => {\n          throw new Error('Terminal termination timeout');\n        }),\n      ]).catch((error) => {\n        this.logger.error('Error terminating terminal', { sessionId, error });\n      });\n\n      // Close memory bank with timeout\n      await Promise.race([\n        this.memoryManager.closeBank(session.memoryBankId),\n        delay(5000).then(() => {\n          throw new Error('Memory bank close timeout');\n        }),\n      ]).catch((error) => {\n        this.logger.error('Error closing memory bank', { sessionId, error });\n      });\n\n      // Clean up\n      this.sessionProfiles.delete(sessionId);\n\n      this.logger.info('Session terminated', {\n        sessionId,\n        duration: session.endTime.getTime() - session.startTime.getTime(),\n      });\n\n      // Persist sessions asynchronously\n      this.persistSessions().catch((error) =>\n        this.logger.error('Failed to persist sessions', error),\n      );\n    } catch (error) {\n      this.logger.error('Error during session termination', { sessionId, error });\n      throw error;\n    }\n  }\n\n  async terminateAllSessions(): Promise<void> {\n    const sessions = this.getActiveSessions();\n\n    // Terminate sessions in batches to avoid overwhelming the system\n    const batchSize = 5;\n    for (let i = 0; i < sessions.length; i += batchSize) {\n      const batch = sessions.slice(i, i + batchSize);\n      await Promise.allSettled(batch.map((session) => this.terminateSession(session.id)));\n    }\n  }\n\n  removeSession(sessionId: string): void {\n    this.sessions.delete(sessionId);\n    this.sessionProfiles.delete(sessionId);\n  }\n\n  async persistSessions(): Promise<void> {\n    if (!this.config.orchestrator.persistSessions) {\n      return;\n    }\n\n    try {\n      await this.persistenceCircuitBreaker.execute(async () => {\n        const data: SessionPersistence = {\n          sessions: Array.from(this.sessions.values())\n            .map((session) => ({\n              ...session,\n              profile: this.sessionProfiles.get(session.id)!,\n            }))\n            .filter((s) => s.profile),\n          taskQueue: [],\n          metrics: {\n            completedTasks: 0,\n            failedTasks: 0,\n            totalTaskDuration: 0,\n          },\n          savedAt: new Date(),\n        };\n\n        await mkdir(dirname(this.persistencePath), { recursive: true });\n        await writeFile(this.persistencePath, JSON.stringify(data, null, 2), 'utf8');\n\n        this.logger.debug('Sessions persisted', { count: data.sessions.length });\n      });\n    } catch (error) {\n      this.logger.error('Failed to persist sessions', error);\n    }\n  }\n\n  async restoreSessions(): Promise<void> {\n    if (!this.config.orchestrator.persistSessions) {\n      return;\n    }\n\n    try {\n      const data = await readFile(this.persistencePath, 'utf8');\n      const persistence: SessionPersistence = JSON.parse(data);\n\n      // Restore only active/idle sessions\n      const sessionsToRestore = persistence.sessions.filter(\n        (s) => s.status === 'active' || s.status === 'idle',\n      );\n\n      for (const sessionData of sessionsToRestore) {\n        try {\n          // Recreate session\n          const session = await this.createSession(sessionData.profile);\n\n          // Update with persisted data\n          Object.assign(session, {\n            id: sessionData.id,\n            startTime: new Date(sessionData.startTime),\n            lastActivity: new Date(sessionData.lastActivity),\n          });\n\n          this.logger.info('Session restored', { sessionId: session.id });\n        } catch (error) {\n          this.logger.error('Failed to restore session', {\n            sessionId: sessionData.id,\n            error,\n          });\n        }\n      }\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n        this.logger.error('Failed to restore sessions', error);\n      }\n    }\n  }\n}\n\n/**\n * Main orchestrator implementation with enhanced features\n */\nexport class Orchestrator implements IOrchestrator {\n  private initialized = false;\n  private shutdownInProgress = false;\n  private sessionManager: ISessionManager;\n  private healthCheckInterval?: number;\n  private maintenanceInterval?: number;\n  private metricsInterval?: number;\n  private agents = new Map<string, AgentProfile>();\n  private taskQueue: Task[] = [];\n  private taskHistory = new Map<string, Task>();\n  private startTime = Date.now();\n  private claudeClient?: ClaudeAPIClient;\n  private configManager: ConfigManager;\n\n  // Metrics tracking\n  private metrics = {\n    completedTasks: 0,\n    failedTasks: 0,\n    totalTaskDuration: 0,\n  };\n\n  // Circuit breakers for critical operations\n  private healthCheckCircuitBreaker: CircuitBreaker;\n  private taskAssignmentCircuitBreaker: CircuitBreaker;\n\n  constructor(\n    private config: Config,\n    private terminalManager: ITerminalManager,\n    private memoryManager: IMemoryManager,\n    private coordinationManager: ICoordinationManager,\n    private mcpServer: IMCPServer,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    this.sessionManager = new SessionManager(\n      terminalManager,\n      memoryManager,\n      eventBus,\n      logger,\n      config,\n    );\n\n    this.configManager = ConfigManager.getInstance();\n\n    // Initialize circuit breakers\n    this.healthCheckCircuitBreaker = circuitBreaker('HealthCheck', {\n      threshold: 3,\n      timeout: 10000,\n      resetTimeout: 30000,\n    });\n\n    this.taskAssignmentCircuitBreaker = circuitBreaker('TaskAssignment', {\n      threshold: 5,\n      timeout: 5000,\n      resetTimeout: 20000,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      throw new InitializationError('Orchestrator already initialized');\n    }\n\n    this.logger.info('Initializing orchestrator...');\n    const startTime = Date.now();\n\n    try {\n      // Initialize components in parallel where possible\n      await Promise.all([\n        this.initializeComponent('Terminal Manager', () => this.terminalManager.initialize()),\n        this.initializeComponent('Memory Manager', () => this.memoryManager.initialize()),\n        this.initializeComponent('Coordination Manager', () =>\n          this.coordinationManager.initialize(),\n        ),\n      ]);\n\n      // MCP server needs to be started after other components\n      await this.initializeComponent('MCP Server', () => this.mcpServer.start());\n\n      // Initialize Claude API client if configured\n      if (this.configManager.isClaudeAPIConfigured()) {\n        try {\n          this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\n          this.logger.info('Claude API client initialized', {\n            model: this.claudeClient.getConfig().model,\n            temperature: this.claudeClient.getConfig().temperature,\n          });\n        } catch (error) {\n          this.logger.warn('Failed to initialize Claude API client', error);\n        }\n      }\n\n      // Restore persisted sessions\n      await this.sessionManager.restoreSessions();\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      // Start background tasks\n      this.startHealthChecks();\n      this.startMaintenanceTasks();\n      this.startMetricsCollection();\n\n      this.initialized = true;\n\n      const initDuration = Date.now() - startTime;\n      this.eventBus.emit(SystemEvents.SYSTEM_READY, { timestamp: new Date() });\n      this.logger.info('Orchestrator initialized successfully', { duration: initDuration });\n    } catch (error) {\n      this.logger.error('Failed to initialize orchestrator', error);\n\n      // Attempt cleanup on initialization failure\n      await this.emergencyShutdown();\n\n      throw new InitializationError('Orchestrator', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized || this.shutdownInProgress) {\n      return;\n    }\n\n    this.shutdownInProgress = true;\n    this.logger.info('Shutting down orchestrator...');\n    const shutdownStart = Date.now();\n\n    try {\n      // Stop background tasks\n      this.stopBackgroundTasks();\n\n      // Save current state\n      await this.sessionManager.persistSessions();\n\n      // Process any remaining critical tasks\n      await this.processShutdownTasks();\n\n      // Terminate all sessions\n      await this.sessionManager.terminateAllSessions();\n\n      // Shutdown components with timeout\n      await Promise.race([\n        this.shutdownComponents(),\n        delay(this.config.orchestrator.shutdownTimeout),\n      ]);\n\n      const shutdownDuration = Date.now() - shutdownStart;\n      this.eventBus.emit(SystemEvents.SYSTEM_SHUTDOWN, { reason: 'Graceful shutdown' });\n      this.logger.info('Orchestrator shutdown complete', { duration: shutdownDuration });\n    } catch (error) {\n      this.logger.error('Error during shutdown', error);\n\n      // Force shutdown if graceful shutdown fails\n      await this.emergencyShutdown();\n\n      throw new ShutdownError('Failed to shutdown gracefully', { error });\n    } finally {\n      this.initialized = false;\n      this.shutdownInProgress = false;\n    }\n  }\n\n  async spawnAgent(profile: AgentProfile): Promise<string> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    // Check agent limit\n    if (this.agents.size >= this.config.orchestrator.maxConcurrentAgents) {\n      throw new SystemError('Maximum concurrent agents reached');\n    }\n\n    // Validate agent profile\n    this.validateAgentProfile(profile);\n\n    this.logger.info('Spawning agent', { agentId: profile.id, type: profile.type });\n\n    try {\n      // Create session with retry\n      const session = await retry(() => this.sessionManager.createSession(profile), {\n        maxAttempts: 3,\n        initialDelay: 2000,\n      });\n\n      // Store agent profile\n      this.agents.set(profile.id, profile);\n\n      // Emit event\n      this.eventBus.emit(SystemEvents.AGENT_SPAWNED, {\n        agentId: profile.id,\n        profile,\n        sessionId: session.id,\n      });\n\n      // Start agent health monitoring\n      this.startAgentHealthMonitoring(profile.id);\n\n      return session.id;\n    } catch (error) {\n      this.logger.error('Failed to spawn agent', { agentId: profile.id, error });\n      throw error;\n    }\n  }\n\n  async terminateAgent(agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    const profile = this.agents.get(agentId);\n    if (!profile) {\n      throw new SystemError(`Agent not found: ${agentId}`);\n    }\n\n    this.logger.info('Terminating agent', { agentId });\n\n    try {\n      // Cancel any assigned tasks\n      await this.cancelAgentTasks(agentId);\n\n      // Find and terminate all sessions for this agent\n      const sessions = this.sessionManager\n        .getActiveSessions()\n        .filter((session) => session.agentId === agentId);\n\n      await Promise.allSettled(\n        sessions.map((session) => this.sessionManager.terminateSession(session.id)),\n      );\n\n      // Remove agent\n      this.agents.delete(agentId);\n\n      // Emit event\n      this.eventBus.emit(SystemEvents.AGENT_TERMINATED, {\n        agentId,\n        reason: 'User requested',\n      });\n    } catch (error) {\n      this.logger.error('Failed to terminate agent', { agentId, error });\n      throw error;\n    }\n  }\n\n  async assignTask(task: Task): Promise<void> {\n    if (!this.initialized) {\n      throw new SystemError('Orchestrator not initialized');\n    }\n\n    // Validate task\n    this.validateTask(task);\n\n    // Store task in history\n    this.taskHistory.set(task.id, task);\n\n    try {\n      await this.taskAssignmentCircuitBreaker.execute(async () => {\n        // Add to queue if no agent assigned\n        if (!task.assignedAgent) {\n          if (this.taskQueue.length >= this.config.orchestrator.taskQueueSize) {\n            throw new SystemError('Task queue is full');\n          }\n\n          this.taskQueue.push(task);\n          this.eventBus.emit(SystemEvents.TASK_CREATED, { task });\n\n          // Try to assign immediately\n          await this.processTaskQueue();\n          return;\n        }\n\n        // Assign to specific agent\n        const agent = this.agents.get(task.assignedAgent);\n        if (!agent) {\n          throw new SystemError(`Agent not found: ${task.assignedAgent}`);\n        }\n\n        await this.coordinationManager.assignTask(task, task.assignedAgent);\n\n        this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\n          taskId: task.id,\n          agentId: task.assignedAgent,\n        });\n      });\n    } catch (error) {\n      this.logger.error('Failed to assign task', { taskId: task.id, error });\n      throw error;\n    }\n  }\n\n  async getHealthStatus(): Promise<HealthStatus> {\n    try {\n      return await this.healthCheckCircuitBreaker.execute(async () => {\n        const components: Record<string, ComponentHealth> = {};\n\n        // Check all components in parallel\n        const [terminal, memory, coordination, mcp] = await Promise.allSettled([\n          this.getComponentHealth(\n            'Terminal Manager',\n            async () => await this.terminalManager.getHealthStatus(),\n          ),\n          this.getComponentHealth(\n            'Memory Manager',\n            async () => await this.memoryManager.getHealthStatus(),\n          ),\n          this.getComponentHealth(\n            'Coordination Manager',\n            async () => await this.coordinationManager.getHealthStatus(),\n          ),\n          this.getComponentHealth('MCP Server', async () => await this.mcpServer.getHealthStatus()),\n        ]);\n\n        // Process results\n        components.terminal = this.processHealthResult(terminal, 'Terminal Manager');\n        components.memory = this.processHealthResult(memory, 'Memory Manager');\n        components.coordination = this.processHealthResult(coordination, 'Coordination Manager');\n        components.mcp = this.processHealthResult(mcp, 'MCP Server');\n\n        // Add orchestrator self-check\n        components.orchestrator = {\n          name: 'Orchestrator',\n          status: 'healthy',\n          lastCheck: new Date(),\n          metrics: {\n            uptime: Date.now() - this.startTime,\n            activeAgents: this.agents.size,\n            queuedTasks: this.taskQueue.length,\n            memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // MB\n          },\n        };\n\n        // Determine overall status\n        const statuses = Object.values(components).map((c) => c.status);\n        let overallStatus: HealthStatus['status'] = 'healthy';\n\n        if (statuses.some((s) => s === 'unhealthy')) {\n          overallStatus = 'unhealthy';\n        } else if (statuses.some((s) => s === 'degraded')) {\n          overallStatus = 'degraded';\n        }\n\n        return {\n          status: overallStatus,\n          components,\n          timestamp: new Date(),\n        };\n      });\n    } catch (error) {\n      this.logger.error('Health check failed', error);\n\n      // Return degraded status if health check fails\n      return {\n        status: 'degraded',\n        components: {\n          orchestrator: {\n            name: 'Orchestrator',\n            status: 'degraded',\n            lastCheck: new Date(),\n            error: 'Health check circuit breaker open',\n          },\n        },\n        timestamp: new Date(),\n      };\n    }\n  }\n\n  async getMetrics(): Promise<OrchestratorMetrics> {\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage();\n\n    const avgTaskDuration =\n      this.metrics.completedTasks > 0\n        ? this.metrics.totalTaskDuration / this.metrics.completedTasks\n        : 0;\n\n    return {\n      uptime: Date.now() - this.startTime,\n      totalAgents: this.agents.size,\n      activeAgents: this.sessionManager.getActiveSessions().length,\n      totalTasks: this.taskHistory.size,\n      completedTasks: this.metrics.completedTasks,\n      failedTasks: this.metrics.failedTasks,\n      queuedTasks: this.taskQueue.length,\n      avgTaskDuration,\n      memoryUsage: memUsage,\n      cpuUsage: cpuUsage,\n      timestamp: new Date(),\n    };\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing maintenance tasks');\n\n    try {\n      // Clean up terminated sessions\n      await this.cleanupTerminatedSessions();\n\n      // Clean up old task history\n      await this.cleanupTaskHistory();\n\n      // Perform component maintenance\n      await Promise.allSettled([\n        this.terminalManager.performMaintenance(),\n        this.memoryManager.performMaintenance(),\n        this.coordinationManager.performMaintenance(),\n      ]);\n\n      // Persist current state\n      await this.sessionManager.persistSessions();\n\n      // Force garbage collection if available\n      if (global.gc) {\n        global.gc();\n      }\n\n      this.logger.debug('Maintenance tasks completed');\n    } catch (error) {\n      this.logger.error('Error during maintenance', error);\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle task lifecycle events\n    this.eventBus.on(SystemEvents.TASK_STARTED, (data: unknown) => {\n      const { taskId, agentId } = data as { taskId: string; agentId: string };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'running';\n        task.startedAt = new Date();\n      }\n    });\n\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: unknown) => {\n      const { taskId, result } = data as { taskId: string; result: unknown };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'completed';\n        task.completedAt = new Date();\n        if (result !== undefined) {\n          task.output = result as Record<string, unknown>;\n        }\n\n        // Update metrics\n        this.metrics.completedTasks++;\n        if (task.startedAt) {\n          this.metrics.totalTaskDuration += task.completedAt.getTime() - task.startedAt.getTime();\n        }\n      }\n\n      await this.processTaskQueue();\n    });\n\n    this.eventBus.on(SystemEvents.TASK_FAILED, async (data: unknown) => {\n      const { taskId, error } = data as { taskId: string; error: Error };\n      const task = this.taskHistory.get(taskId);\n      if (task) {\n        task.status = 'failed';\n        task.completedAt = new Date();\n        task.error = error;\n\n        // Update metrics\n        this.metrics.failedTasks++;\n      }\n\n      // Retry or requeue based on configuration\n      await this.handleTaskFailure(taskId, error);\n    });\n\n    // Handle agent events\n    this.eventBus.on(SystemEvents.AGENT_ERROR, async (data: unknown) => {\n      const { agentId, error } = data as { agentId: string; error: Error };\n      this.logger.error('Agent error', { agentId, error });\n\n      // Implement agent recovery\n      await this.handleAgentError(agentId, error);\n    });\n\n    this.eventBus.on(SystemEvents.AGENT_IDLE, async (data: unknown) => {\n      const { agentId } = data as { agentId: string };\n      // Update session status\n      const sessions = this.sessionManager.getActiveSessions().filter((s) => s.agentId === agentId);\n      sessions.forEach((s) => (s.status = 'idle'));\n\n      // Try to assign queued tasks\n      await this.processTaskQueue();\n    });\n\n    // Handle system events\n    this.eventBus.on(SystemEvents.SYSTEM_ERROR, (data: unknown) => {\n      const { error, component } = data as { error: Error; component: string };\n      this.logger.error('System error', { component, error });\n\n      // Implement system-level error recovery\n      this.handleSystemError(component, error);\n    });\n\n    // Handle resource events\n    this.eventBus.on(SystemEvents.DEADLOCK_DETECTED, (data: unknown) => {\n      const { agents, resources } = data as { agents: string[]; resources: string[] };\n      this.logger.error('Deadlock detected', { agents, resources });\n\n      // Implement deadlock resolution\n      this.resolveDeadlock(agents, resources);\n    });\n  }\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        const health = await this.getHealthStatus();\n        this.eventBus.emit(SystemEvents.SYSTEM_HEALTHCHECK, { status: health });\n\n        if (health.status === 'unhealthy') {\n          this.logger.warn('System health check failed', health);\n\n          // Attempt recovery for unhealthy components\n          await this.recoverUnhealthyComponents(health);\n        }\n      } catch (error) {\n        this.logger.error('Health check error', error);\n      }\n    }, this.config.orchestrator.healthCheckInterval);\n  }\n\n  private startMaintenanceTasks(): void {\n    this.maintenanceInterval = setInterval(async () => {\n      await this.performMaintenance();\n    }, this.config.orchestrator.maintenanceInterval || 300000); // 5 minutes default\n  }\n\n  private startMetricsCollection(): void {\n    this.metricsInterval = setInterval(async () => {\n      try {\n        const metrics = await this.getMetrics();\n        this.logger.debug('Metrics collected', metrics);\n\n        // Emit metrics event for monitoring systems\n        this.eventBus.emit('metrics:collected', metrics);\n      } catch (error) {\n        this.logger.error('Metrics collection error', error);\n      }\n    }, this.config.orchestrator.metricsInterval || 60000); // 1 minute default\n  }\n\n  private stopBackgroundTasks(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n    if (this.maintenanceInterval) {\n      clearInterval(this.maintenanceInterval);\n    }\n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n    }\n  }\n\n  private async shutdownComponents(): Promise<void> {\n    const shutdownTasks = [\n      this.shutdownComponent('Terminal Manager', () => this.terminalManager.shutdown()),\n      this.shutdownComponent('Memory Manager', () => this.memoryManager.shutdown()),\n      this.shutdownComponent('Coordination Manager', () => this.coordinationManager.shutdown()),\n      this.shutdownComponent('MCP Server', () => this.mcpServer.stop()),\n    ];\n\n    const results = await Promise.allSettled(shutdownTasks);\n\n    // Log any shutdown failures\n    results.forEach((result, index) => {\n      if (result.status === 'rejected') {\n        const componentName = [\n          'Terminal Manager',\n          'Memory Manager',\n          'Coordination Manager',\n          'MCP Server',\n        ][index];\n        this.logger.error(`Failed to shutdown ${componentName}`, result.reason);\n      }\n    });\n  }\n\n  private async emergencyShutdown(): Promise<void> {\n    this.logger.warn('Performing emergency shutdown');\n\n    try {\n      // Force stop all components\n      await Promise.allSettled([\n        this.terminalManager.shutdown().catch(() => {}),\n        this.memoryManager.shutdown().catch(() => {}),\n        this.coordinationManager.shutdown().catch(() => {}),\n        this.mcpServer.stop().catch(() => {}),\n      ]);\n    } catch (error) {\n      this.logger.error('Emergency shutdown error', error);\n    }\n  }\n\n  private async processTaskQueue(): Promise<void> {\n    if (this.taskQueue.length === 0) {\n      return;\n    }\n\n    const availableAgents = await this.getAvailableAgents();\n\n    while (this.taskQueue.length > 0 && availableAgents.length > 0) {\n      const task = this.taskQueue.shift()!;\n      const agent = this.selectAgentForTask(task, availableAgents);\n\n      if (agent) {\n        task.assignedAgent = agent.id;\n        task.status = 'assigned';\n\n        try {\n          await this.coordinationManager.assignTask(task, agent.id);\n\n          this.eventBus.emit(SystemEvents.TASK_ASSIGNED, {\n            taskId: task.id,\n            agentId: agent.id,\n          });\n\n          // Remove agent from available list\n          const index = availableAgents.indexOf(agent);\n          availableAgents.splice(index, 1);\n        } catch (error) {\n          // Put task back in queue\n          this.taskQueue.unshift(task);\n          this.logger.error('Failed to assign task', { taskId: task.id, error });\n          break;\n        }\n      } else {\n        // No suitable agent, put task back\n        this.taskQueue.unshift(task);\n        break;\n      }\n    }\n  }\n\n  private async getAvailableAgents(): Promise<AgentProfile[]> {\n    const sessions = this.sessionManager.getActiveSessions();\n    const available: AgentProfile[] = [];\n\n    for (const session of sessions) {\n      if (session.status === 'idle' || session.status === 'active') {\n        const profile = this.agents.get(session.agentId);\n        if (profile) {\n          try {\n            const taskCount = await this.coordinationManager.getAgentTaskCount(profile.id);\n            if (taskCount < profile.maxConcurrentTasks) {\n              available.push(profile);\n            }\n          } catch (error) {\n            this.logger.error('Failed to get agent task count', { agentId: profile.id, error });\n          }\n        }\n      }\n    }\n\n    return available.sort((a, b) => b.priority - a.priority);\n  }\n\n  private selectAgentForTask(task: Task, agents: AgentProfile[]): AgentProfile | undefined {\n    // Score agents based on capabilities, load, and priority\n    const scoredAgents = agents.map((agent) => {\n      let score = agent.priority * 10;\n\n      // Check capability match\n      const requiredCapabilities = (task.metadata?.requiredCapabilities as string[]) || [];\n      const matchedCapabilities = requiredCapabilities.filter((cap) =>\n        agent.capabilities.includes(cap),\n      ).length;\n\n      if (requiredCapabilities.length > 0 && matchedCapabilities === 0) {\n        return { agent, score: -1 }; // Can't handle task\n      }\n\n      score += matchedCapabilities * 5;\n\n      // Prefer agents with matching type\n      if (task.type === agent.type) {\n        score += 20;\n      }\n\n      return { agent, score };\n    });\n\n    // Filter out agents that can't handle the task\n    const eligibleAgents = scoredAgents.filter(({ score }) => score >= 0);\n\n    if (eligibleAgents.length === 0) {\n      return undefined;\n    }\n\n    // Select agent with highest score\n    eligibleAgents.sort((a, b) => b.score - a.score);\n    return eligibleAgents[0].agent;\n  }\n\n  private async getComponentHealth(\n    name: string,\n    check: () => Promise<{ healthy: boolean; error?: string; metrics?: Record<string, number> }>,\n  ): Promise<ComponentHealth> {\n    try {\n      const result = await Promise.race([\n        check(),\n        delay(5000).then(() => ({ healthy: false, error: 'Health check timeout' })),\n      ]);\n\n      const health: ComponentHealth = {\n        name,\n        status: result.healthy ? 'healthy' : 'unhealthy',\n        lastCheck: new Date(),\n      };\n      if (result.error !== undefined) {\n        health.error = result.error;\n      }\n      if ('metrics' in result && result.metrics !== undefined) {\n        health.metrics = result.metrics;\n      }\n      return health;\n    } catch (error) {\n      return {\n        name,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private processHealthResult(\n    result: PromiseSettledResult<ComponentHealth>,\n    componentName: string,\n  ): ComponentHealth {\n    if (result.status === 'fulfilled') {\n      return result.value;\n    } else {\n      return {\n        name: componentName,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        error: result.reason?.message || 'Health check failed',\n      };\n    }\n  }\n\n  private async initializeComponent(name: string, init: () => Promise<void>): Promise<void> {\n    try {\n      await retry(init, { maxAttempts: 3, initialDelay: 2000 });\n      this.logger.info(`${name} initialized`);\n    } catch (error) {\n      this.logger.error(`Failed to initialize ${name}`, error);\n      throw new InitializationError(name, { error });\n    }\n  }\n\n  private async shutdownComponent(name: string, shutdown: () => Promise<void>): Promise<void> {\n    try {\n      await Promise.race([\n        shutdown(),\n        delay(10000), // 10 second timeout per component\n      ]);\n      this.logger.info(`${name} shut down`);\n    } catch (error) {\n      this.logger.error(`Failed to shutdown ${name}`, error);\n      throw error;\n    }\n  }\n\n  private validateAgentProfile(profile: AgentProfile): void {\n    if (!profile.id || !profile.name || !profile.type) {\n      throw new Error('Invalid agent profile: missing required fields');\n    }\n\n    if (profile.maxConcurrentTasks < 1) {\n      throw new Error('Invalid agent profile: maxConcurrentTasks must be at least 1');\n    }\n\n    if (this.agents.has(profile.id)) {\n      throw new Error(`Agent with ID ${profile.id} already exists`);\n    }\n  }\n\n  private validateTask(task: Task): void {\n    if (!task.id || !task.type || !task.description) {\n      throw new Error('Invalid task: missing required fields');\n    }\n\n    if (task.priority < 0 || task.priority > 100) {\n      throw new Error('Invalid task: priority must be between 0 and 100');\n    }\n\n    if (this.taskHistory.has(task.id)) {\n      throw new Error(`Task with ID ${task.id} already exists`);\n    }\n  }\n\n  private async handleAgentError(agentId: string, error: Error): Promise<void> {\n    const profile = this.agents.get(agentId);\n    if (!profile) {\n      return;\n    }\n\n    // Log error details\n    this.logger.error('Handling agent error', { agentId, error });\n\n    // Check if agent should be restarted\n    const errorCount = (profile.metadata?.errorCount as number) || 0;\n    profile.metadata = { ...profile.metadata, errorCount: errorCount + 1 };\n\n    if (errorCount < 3) {\n      // Attempt to restart agent\n      try {\n        await this.terminateAgent(agentId);\n        await delay(2000); // Wait before restart\n        await this.spawnAgent({ ...profile, metadata: { ...profile.metadata, errorCount: 0 } });\n        this.logger.info('Agent restarted after error', { agentId });\n      } catch (restartError) {\n        this.logger.error('Failed to restart agent', { agentId, error: restartError });\n      }\n    } else {\n      // Too many errors, terminate agent\n      this.logger.error('Agent exceeded error threshold, terminating', { agentId, errorCount });\n      await this.terminateAgent(agentId);\n    }\n  }\n\n  private async handleTaskFailure(taskId: string, error: Error): Promise<void> {\n    const task = this.taskHistory.get(taskId);\n    if (!task) {\n      return;\n    }\n\n    const retryCount = (task.metadata?.retryCount as number) || 0;\n    const maxRetries = this.config.orchestrator.taskMaxRetries || 3;\n\n    if (retryCount < maxRetries) {\n      // Retry task\n      task.metadata = { ...task.metadata, retryCount: retryCount + 1 };\n      task.status = 'queued';\n      delete task.assignedAgent;\n\n      // Add back to queue with delay\n      setTimeout(\n        () => {\n          this.taskQueue.push(task);\n          this.processTaskQueue();\n        },\n        Math.pow(2, retryCount) * 1000,\n      ); // Exponential backoff\n\n      this.logger.info('Task queued for retry', { taskId, retryCount: retryCount + 1 });\n    } else {\n      this.logger.error('Task exceeded retry limit', { taskId, retryCount });\n    }\n  }\n\n  private handleSystemError(component: string, error: Error): void {\n    // Implement system-level error recovery strategies\n    this.logger.error('Handling system error', { component, error });\n\n    // TODO: Implement specific recovery strategies based on component and error type\n  }\n\n  private async resolveDeadlock(agents: string[], resources: string[]): Promise<void> {\n    this.logger.warn('Resolving deadlock', { agents, resources });\n\n    // Simple deadlock resolution: cancel lowest priority agent's tasks\n    const agentProfiles = agents.map((id) => this.agents.get(id)).filter(Boolean) as AgentProfile[];\n\n    if (agentProfiles.length === 0) {\n      return;\n    }\n\n    // Sort by priority (lowest first)\n    agentProfiles.sort((a, b) => a.priority - b.priority);\n\n    // Cancel tasks for lowest priority agent\n    const targetAgent = agentProfiles[0];\n    await this.cancelAgentTasks(targetAgent.id);\n\n    this.logger.info('Deadlock resolved by cancelling tasks', { agentId: targetAgent.id });\n  }\n\n  private async cancelAgentTasks(agentId: string): Promise<void> {\n    try {\n      const tasks = await this.coordinationManager.getAgentTasks(agentId);\n\n      for (const task of tasks) {\n        await this.coordinationManager.cancelTask(task.id);\n\n        // Update task status\n        const trackedTask = this.taskHistory.get(task.id);\n        if (trackedTask) {\n          trackedTask.status = 'cancelled';\n          trackedTask.completedAt = new Date();\n        }\n\n        this.eventBus.emit(SystemEvents.TASK_CANCELLED, {\n          taskId: task.id,\n          reason: 'Agent termination',\n        });\n      }\n    } catch (error) {\n      this.logger.error('Failed to cancel agent tasks', { agentId, error });\n    }\n  }\n\n  private startAgentHealthMonitoring(agentId: string): void {\n    // TODO: Implement periodic health checks for individual agents\n  }\n\n  private async recoverUnhealthyComponents(health: HealthStatus): Promise<void> {\n    for (const [name, component] of Object.entries(health.components)) {\n      if (component.status === 'unhealthy') {\n        this.logger.warn('Attempting to recover unhealthy component', { name });\n\n        // TODO: Implement component-specific recovery strategies\n        switch (name) {\n          case 'Terminal Manager':\n            // Restart terminal pools, etc.\n            break;\n          case 'Memory Manager':\n            // Clear cache, reconnect to backends, etc.\n            break;\n          case 'Coordination Manager':\n            // Reset locks, clear message queues, etc.\n            break;\n          case 'MCP Server':\n            // Restart server, reset connections, etc.\n            break;\n        }\n      }\n    }\n  }\n\n  private async cleanupTerminatedSessions(): Promise<void> {\n    const allSessions = this.sessionManager.getActiveSessions();\n    const terminatedSessions = allSessions.filter((s) => (s as any).status === 'terminated');\n\n    const cutoffTime = Date.now() - (this.config.orchestrator.sessionRetentionMs || 3600000); // 1 hour default\n\n    for (const session of terminatedSessions) {\n      const typedSession = session as any;\n      if (typedSession.endTime && typedSession.endTime.getTime() < cutoffTime) {\n        await this.sessionManager.terminateSession(typedSession.id);\n        this.logger.debug('Cleaned up old session', { sessionId: typedSession.id });\n      }\n    }\n  }\n\n  private async cleanupTaskHistory(): Promise<void> {\n    const cutoffTime = Date.now() - (this.config.orchestrator.taskHistoryRetentionMs || 86400000); // 24 hours default\n\n    for (const [taskId, task] of this.taskHistory.entries()) {\n      if (task.completedAt && task.completedAt.getTime() < cutoffTime) {\n        this.taskHistory.delete(taskId);\n        this.logger.debug('Cleaned up old task', { taskId });\n      }\n    }\n  }\n\n  private async processShutdownTasks(): Promise<void> {\n    // Process any critical tasks before shutdown\n    const criticalTasks = this.taskQueue.filter(\n      (t) => t.priority >= 90 || t.metadata?.critical === true,\n    );\n\n    if (criticalTasks.length > 0) {\n      this.logger.info('Processing critical tasks before shutdown', {\n        count: criticalTasks.length,\n      });\n\n      // TODO: Implement critical task processing\n    }\n  }\n\n  /**\n   * Get Claude API client instance\n   */\n  getClaudeClient(): ClaudeAPIClient | undefined {\n    return this.claudeClient;\n  }\n\n  /**\n   * Update Claude API configuration dynamically\n   */\n  updateClaudeConfig(config: Partial<Config['claude']>): void {\n    this.configManager.setClaudeConfig(config);\n\n    if (this.claudeClient) {\n      this.claudeClient.updateConfig(config);\n    } else if (this.configManager.isClaudeAPIConfigured()) {\n      // Initialize Claude client with new config\n      try {\n        this.claudeClient = new ClaudeAPIClient(this.logger, this.configManager);\n        this.logger.info('Claude API client initialized with new configuration');\n      } catch (error) {\n        this.logger.error('Failed to initialize Claude API client', error);\n      }\n    }\n  }\n\n  /**\n   * Execute a Claude API request\n   */\n  async executeClaudeRequest(\n    prompt: string,\n    options?: {\n      model?: string;\n      temperature?: number;\n      maxTokens?: number;\n      systemPrompt?: string;\n    },\n  ): Promise<string | null> {\n    if (!this.claudeClient) {\n      this.logger.error('Claude API client not initialized');\n      return null;\n    }\n\n    try {\n      const response = await this.claudeClient.complete(prompt, options as any);\n      return response;\n    } catch (error) {\n      this.logger.error('Claude API request failed', error);\n      return null;\n    }\n  }\n}\n"],"names":["SystemEvents","SystemError","InitializationError","ShutdownError","delay","retry","circuitBreaker","mkdir","writeFile","readFile","join","dirname","ClaudeAPIClient","ConfigManager","SessionManager","sessions","Map","sessionProfiles","persistencePath","persistenceCircuitBreaker","terminalManager","memoryManager","eventBus","logger","config","orchestrator","dataDir","threshold","timeout","resetTimeout","createSession","profile","terminalId","spawnTerminal","maxAttempts","initialDelay","memoryBankId","createBank","id","session","Date","now","Math","random","toString","substr","agentId","startTime","status","lastActivity","set","info","sessionId","persistSessions","catch","error","getSession","get","getActiveSessions","Array","from","values","filter","terminateSession","Error","endTime","Promise","race","terminateTerminal","then","closeBank","delete","duration","getTime","terminateAllSessions","batchSize","i","length","batch","slice","allSettled","map","removeSession","execute","data","s","taskQueue","metrics","completedTasks","failedTasks","totalTaskDuration","savedAt","recursive","JSON","stringify","debug","count","restoreSessions","persistence","parse","sessionsToRestore","sessionData","Object","assign","code","Orchestrator","initialized","shutdownInProgress","sessionManager","healthCheckInterval","maintenanceInterval","metricsInterval","agents","taskHistory","claudeClient","configManager","healthCheckCircuitBreaker","taskAssignmentCircuitBreaker","coordinationManager","mcpServer","getInstance","initialize","all","initializeComponent","start","isClaudeAPIConfigured","model","getConfig","temperature","warn","setupEventHandlers","startHealthChecks","startMaintenanceTasks","startMetricsCollection","initDuration","emit","SYSTEM_READY","timestamp","emergencyShutdown","shutdown","shutdownStart","stopBackgroundTasks","processShutdownTasks","shutdownComponents","shutdownTimeout","shutdownDuration","SYSTEM_SHUTDOWN","reason","spawnAgent","size","maxConcurrentAgents","validateAgentProfile","type","AGENT_SPAWNED","startAgentHealthMonitoring","terminateAgent","cancelAgentTasks","AGENT_TERMINATED","assignTask","task","validateTask","assignedAgent","taskQueueSize","push","TASK_CREATED","processTaskQueue","agent","TASK_ASSIGNED","taskId","getHealthStatus","components","terminal","memory","coordination","mcp","getComponentHealth","processHealthResult","name","lastCheck","uptime","activeAgents","queuedTasks","memoryUsage","process","heapUsed","statuses","c","overallStatus","some","getMetrics","memUsage","cpuUsage","avgTaskDuration","totalAgents","totalTasks","performMaintenance","cleanupTerminatedSessions","cleanupTaskHistory","global","gc","on","TASK_STARTED","startedAt","TASK_COMPLETED","result","completedAt","undefined","output","TASK_FAILED","handleTaskFailure","AGENT_ERROR","handleAgentError","AGENT_IDLE","forEach","SYSTEM_ERROR","component","handleSystemError","DEADLOCK_DETECTED","resources","resolveDeadlock","setInterval","health","SYSTEM_HEALTHCHECK","recoverUnhealthyComponents","clearInterval","shutdownTasks","shutdownComponent","stop","results","index","componentName","availableAgents","getAvailableAgents","shift","selectAgentForTask","indexOf","splice","unshift","available","taskCount","getAgentTaskCount","maxConcurrentTasks","sort","a","b","priority","scoredAgents","score","requiredCapabilities","metadata","matchedCapabilities","cap","capabilities","includes","eligibleAgents","check","healthy","message","value","init","has","description","errorCount","restartError","retryCount","maxRetries","taskMaxRetries","setTimeout","pow","agentProfiles","Boolean","targetAgent","tasks","getAgentTasks","cancelTask","trackedTask","TASK_CANCELLED","entries","allSessions","terminatedSessions","cutoffTime","sessionRetentionMs","typedSession","taskHistoryRetentionMs","criticalTasks","t","critical","getClaudeClient","updateClaudeConfig","setClaudeConfig","updateConfig","executeClaudeRequest","prompt","options","response","complete"],"mappings":"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"}