{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/hook-manager.ts"],"sourcesContent":["/**\n * Agentic Flow Hook Manager\n * \n * Central manager for all agentic-flow hooks, providing registration,\n * execution, and lifecycle management.\n */\n\nimport { EventEmitter } from 'events';\nimport { Logger } from '../../core/logger.js';\nimport type {\n  AgenticHookContext,\n  AgenticHookType,\n  HookFilter,\n  HookHandler,\n  HookHandlerResult,\n  HookOptions,\n  HookPayload,\n  HookPipeline,\n  HookRegistration,\n  HookRegistry,\n  PipelineMetrics,\n  PipelineStage,\n  SideEffect,\n} from './types.js';\n\nconst logger = new Logger({ \n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'AgenticHookManager' });\n\nexport class AgenticHookManager extends EventEmitter implements HookRegistry {\n  private hooks: Map<AgenticHookType, HookRegistration[]> = new Map();\n  private pipelines: Map<string, HookPipeline> = new Map();\n  private metrics: Map<string, any> = new Map();\n  private activeExecutions: Set<string> = new Set();\n  \n  constructor() {\n    super();\n    this.initializeMetrics();\n  }\n\n  /**\n   * Register a new hook\n   */\n  register(registration: HookRegistration): void {\n    const { type, id } = registration;\n    \n    // Validate registration\n    this.validateRegistration(registration);\n    \n    // Get or create hook list for type\n    if (!this.hooks.has(type)) {\n      this.hooks.set(type, []);\n    }\n    \n    const hookList = this.hooks.get(type)!;\n    \n    // Check for duplicate ID\n    if (hookList.some(h => h.id === id)) {\n      throw new Error(`Hook with ID '${id}' already registered for type '${type}'`);\n    }\n    \n    // Insert hook sorted by priority (higher priority first)\n    const insertIndex = hookList.findIndex(h => h.priority < registration.priority);\n    if (insertIndex === -1) {\n      hookList.push(registration);\n    } else {\n      hookList.splice(insertIndex, 0, registration);\n    }\n    \n    logger.info(`Registered hook '${id}' for type '${type}' with priority ${registration.priority}`);\n    this.emit('hook:registered', { type, registration });\n    \n    // Update metrics\n    this.updateMetric('hooks.registered', 1);\n  }\n\n  /**\n   * Unregister a hook\n   */\n  unregister(id: string): void {\n    let found = false;\n    \n    for (const [type, hookList] of this.hooks.entries()) {\n      const index = hookList.findIndex(h => h.id === id);\n      if (index !== -1) {\n        hookList.splice(index, 1);\n        found = true;\n        \n        logger.info(`Unregistered hook '${id}' from type '${type}'`);\n        this.emit('hook:unregistered', { type, id });\n        \n        // Clean up empty lists\n        if (hookList.length === 0) {\n          this.hooks.delete(type);\n        }\n        \n        break;\n      }\n    }\n    \n    if (!found) {\n      throw new Error(`Hook with ID '${id}' not found`);\n    }\n    \n    this.updateMetric('hooks.unregistered', 1);\n  }\n\n  /**\n   * Get hooks by type with optional filtering\n   */\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[] {\n    const hookList = this.hooks.get(type) || [];\n    \n    if (!filter) {\n      return [...hookList];\n    }\n    \n    return hookList.filter(hook => this.matchesFilter(hook, filter));\n  }\n\n  /**\n   * Execute hooks for a given type\n   */\n  async executeHooks(\n    type: AgenticHookType,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const executionId = this.generateExecutionId();\n    this.activeExecutions.add(executionId);\n    \n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n    \n    try {\n      // Get applicable hooks\n      const hooks = this.getHooks(type, this.createFilterFromPayload(payload));\n      \n      logger.debug(`Executing ${hooks.length} hooks for type '${type}'`);\n      this.emit('hooks:executing', { type, count: hooks.length, executionId });\n      \n      // Execute hooks in order\n      let modifiedPayload = payload;\n      for (const hook of hooks) {\n        try {\n          const result = await this.executeHook(hook, modifiedPayload, context);\n          results.push(result);\n          \n          // Handle side effects\n          if (result.sideEffects) {\n            await this.processSideEffects(result.sideEffects, context);\n          }\n          \n          // Update payload if modified\n          if (result.modified && result.payload) {\n            modifiedPayload = result.payload;\n          }\n          \n          // Check if we should continue\n          if (!result.continue) {\n            logger.debug(`Hook '${hook.id}' halted execution chain`);\n            break;\n          }\n        } catch (error) {\n          await this.handleHookError(hook, error as Error, context);\n          \n          // Determine if we should continue after error\n          if (hook.options?.errorHandler) {\n            hook.options.errorHandler(error as Error);\n          } else {\n            throw error; // Re-throw if no error handler\n          }\n        }\n      }\n      \n      // Update metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric('hooks.executions', 1);\n      this.updateMetric('hooks.totalDuration', duration);\n      this.updateMetric(`hooks.${type}.executions`, 1);\n      this.updateMetric(`hooks.${type}.duration`, duration);\n      \n      this.emit('hooks:executed', { \n        type, \n        results, \n        duration, \n        executionId \n      });\n      \n      return results;\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Create a new hook pipeline\n   */\n  createPipeline(config: Partial<HookPipeline>): HookPipeline {\n    const pipeline: HookPipeline = {\n      id: config.id || this.generatePipelineId(),\n      name: config.name || 'Unnamed Pipeline',\n      stages: config.stages || [],\n      errorStrategy: config.errorStrategy || 'fail-fast',\n      metrics: {\n        executions: 0,\n        avgDuration: 0,\n        errorRate: 0,\n        throughput: 0,\n      },\n    };\n    \n    this.pipelines.set(pipeline.id, pipeline);\n    logger.info(`Created pipeline '${pipeline.name}' with ID '${pipeline.id}'`);\n    \n    return pipeline;\n  }\n\n  /**\n   * Execute a pipeline\n   */\n  async executePipeline(\n    pipelineId: string,\n    initialPayload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const pipeline = this.pipelines.get(pipelineId);\n    if (!pipeline) {\n      throw new Error(`Pipeline '${pipelineId}' not found`);\n    }\n    \n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n    let currentPayload = initialPayload;\n    \n    try {\n      for (const stage of pipeline.stages) {\n        // Check stage condition\n        if (stage.condition && !stage.condition(context)) {\n          logger.debug(`Skipping stage '${stage.name}' due to condition`);\n          continue;\n        }\n        \n        // Execute stage hooks\n        const stageResults = await this.executeStage(\n          stage, \n          currentPayload, \n          context\n        );\n        \n        // Apply stage transform if provided\n        if (stage.transform) {\n          for (let i = 0; i < stageResults.length; i++) {\n            stageResults[i] = stage.transform(stageResults[i]);\n          }\n        }\n        \n        results.push(...stageResults);\n        \n        // Update payload for next stage\n        const lastModified = stageResults\n          .reverse()\n          .find(r => r.modified && r.payload);\n        if (lastModified) {\n          currentPayload = lastModified.payload;\n        }\n      }\n      \n      // Update pipeline metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, false);\n      \n      return results;\n    } catch (error) {\n      // Update error metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, true);\n      \n      // Handle error based on strategy\n      if (pipeline.errorStrategy === 'rollback') {\n        await this.rollbackPipeline(pipeline, results, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): Record<string, any> {\n    const metrics: Record<string, any> = {};\n    \n    for (const [key, value] of this.metrics.entries()) {\n      metrics[key] = value;\n    }\n    \n    // Add computed metrics\n    metrics['hooks.count'] = this.getTotalHookCount();\n    metrics['hooks.types'] = Array.from(this.hooks.keys());\n    metrics['pipelines.count'] = this.pipelines.size;\n    metrics['executions.active'] = this.activeExecutions.size;\n    \n    return metrics;\n  }\n\n  // ===== Private Methods =====\n\n  private validateRegistration(registration: HookRegistration): void {\n    if (!registration.id) {\n      throw new Error('Hook registration must have an ID');\n    }\n    \n    if (!registration.type) {\n      throw new Error('Hook registration must have a type');\n    }\n    \n    if (typeof registration.handler !== 'function') {\n      throw new Error('Hook registration must have a handler function');\n    }\n    \n    if (registration.priority < 0) {\n      throw new Error('Hook priority must be non-negative');\n    }\n  }\n\n  private matchesFilter(hook: HookRegistration, filter: HookFilter): boolean {\n    if (!hook.filter) {\n      return true; // No filter means hook applies to all\n    }\n    \n    // Check providers\n    if (filter.providers && hook.filter.providers) {\n      const hasProvider = filter.providers.some(p => \n        hook.filter!.providers!.includes(p)\n      );\n      if (!hasProvider) return false;\n    }\n    \n    // Check models\n    if (filter.models && hook.filter.models) {\n      const hasModel = filter.models.some(m => \n        hook.filter!.models!.includes(m)\n      );\n      if (!hasModel) return false;\n    }\n    \n    // Check patterns\n    if (filter.patterns && hook.filter.patterns) {\n      // Complex pattern matching logic here\n      // For now, simplified version\n      return true;\n    }\n    \n    // Check conditions\n    if (filter.conditions && hook.filter.conditions) {\n      // Evaluate conditions\n      // Simplified for now\n      return true;\n    }\n    \n    return true;\n  }\n\n  private createFilterFromPayload(payload: HookPayload): HookFilter | undefined {\n    const filter: HookFilter = {};\n    \n    // Extract filter criteria from payload\n    if ('provider' in payload) {\n      filter.providers = [payload.provider];\n    }\n    \n    if ('model' in payload) {\n      filter.models = [payload.model];\n    }\n    \n    if ('operation' in payload) {\n      filter.operations = [payload.operation];\n    }\n    \n    if ('namespace' in payload) {\n      filter.namespaces = [payload.namespace];\n    }\n    \n    return Object.keys(filter).length > 0 ? filter : undefined;\n  }\n\n  private async executeHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Check cache if enabled\n      if (hook.options?.cache?.enabled) {\n        const cacheKey = hook.options.cache.key(payload);\n        const cached = this.getCachedResult(hook.id, cacheKey);\n        if (cached) {\n          this.updateMetric('hooks.cacheHits', 1);\n          return cached;\n        }\n      }\n      \n      // Execute with timeout if specified\n      let resultPromise = hook.handler(payload, context);\n      \n      if (hook.options?.timeout) {\n        resultPromise = this.withTimeout(\n          resultPromise, \n          hook.options.timeout,\n          `Hook '${hook.id}' timed out`\n        );\n      }\n      \n      const result = await resultPromise;\n      \n      // Cache result if enabled\n      if (hook.options?.cache?.enabled && result) {\n        const cacheKey = hook.options.cache.key(payload);\n        this.cacheResult(hook.id, cacheKey, result, hook.options.cache.ttl);\n      }\n      \n      // Update hook-specific metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric(`hooks.${hook.id}.executions`, 1);\n      this.updateMetric(`hooks.${hook.id}.duration`, duration);\n      \n      return result;\n    } catch (error) {\n      // Handle retries if configured\n      if (hook.options?.retries && hook.options.retries > 0) {\n        logger.warn(`Hook '${hook.id}' failed, retrying...`);\n        return this.retryHook(hook, payload, context, hook.options.retries);\n      }\n      \n      // Use fallback if provided\n      if (hook.options?.fallback) {\n        logger.warn(`Hook '${hook.id}' failed, using fallback`);\n        return hook.options.fallback(payload, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  private async retryHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext,\n    retriesLeft: number\n  ): Promise<HookHandlerResult> {\n    for (let i = 0; i < retriesLeft; i++) {\n      try {\n        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff\n        return await hook.handler(payload, context);\n      } catch (error) {\n        if (i === retriesLeft - 1) {\n          throw error; // Last retry failed\n        }\n      }\n    }\n    \n    // Should not reach here\n    throw new Error('Retry logic error');\n  }\n\n  private async processSideEffects(\n    sideEffects: SideEffect[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    for (const effect of sideEffects) {\n      try {\n        await this.processSideEffect(effect, context);\n      } catch (error) {\n        logger.error(`Failed to process side effect: ${effect.type}`, error);\n        // Continue processing other side effects\n      }\n    }\n  }\n\n  private async processSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    switch (effect.type) {\n      case 'memory':\n        await this.processMemorySideEffect(effect, context);\n        break;\n      \n      case 'neural':\n        await this.processNeuralSideEffect(effect, context);\n        break;\n      \n      case 'metric':\n        this.processMetricSideEffect(effect);\n        break;\n      \n      case 'notification':\n        this.processNotificationSideEffect(effect);\n        break;\n      \n      case 'log':\n        this.processLogSideEffect(effect);\n        break;\n    }\n  }\n\n  private async processMemorySideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement memory side effect processing\n    // This would integrate with the memory service\n    logger.debug(`Processing memory side effect: ${effect.action}`, effect.data);\n  }\n\n  private async processNeuralSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement neural side effect processing\n    // This would integrate with the neural service\n    logger.debug(`Processing neural side effect: ${effect.action}`, effect.data);\n  }\n\n  private processMetricSideEffect(effect: SideEffect): void {\n    if (effect.action === 'update') {\n      this.updateMetric(effect.data.name, effect.data.value);\n    } else if (effect.action === 'increment') {\n      this.updateMetric(effect.data.name, 1);\n    }\n  }\n\n  private processNotificationSideEffect(effect: SideEffect): void {\n    this.emit('notification', effect.data);\n  }\n\n  private processLogSideEffect(effect: SideEffect): void {\n    const { level = 'info', message, data } = effect.data;\n    logger[level as keyof Logger](message, data);\n  }\n\n  private async handleHookError(\n    hook: HookRegistration,\n    error: Error,\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.error(`Hook '${hook.id}' error:`, error);\n    \n    this.updateMetric('hooks.errors', 1);\n    this.updateMetric(`hooks.${hook.id}.errors`, 1);\n    \n    this.emit('hook:error', {\n      hookId: hook.id,\n      type: hook.type,\n      error,\n      context,\n    });\n  }\n\n  private async executeStage(\n    stage: PipelineStage,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    if (stage.parallel) {\n      // Execute hooks in parallel\n      const promises = stage.hooks.map(hook => \n        this.executeHook(hook, payload, context)\n      );\n      return Promise.all(promises);\n    } else {\n      // Execute hooks sequentially\n      const results: HookHandlerResult[] = [];\n      let currentPayload = payload;\n      \n      for (const hook of stage.hooks) {\n        const result = await this.executeHook(hook, currentPayload, context);\n        results.push(result);\n        \n        if (result.modified && result.payload) {\n          currentPayload = result.payload;\n        }\n        \n        if (!result.continue) {\n          break;\n        }\n      }\n      \n      return results;\n    }\n  }\n\n  private updatePipelineMetrics(\n    pipeline: HookPipeline,\n    duration: number,\n    hasError: boolean\n  ): void {\n    const metrics = pipeline.metrics;\n    \n    metrics.executions++;\n    metrics.avgDuration = \n      (metrics.avgDuration * (metrics.executions - 1) + duration) / \n      metrics.executions;\n    \n    if (hasError) {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1) + 1) / \n        metrics.executions;\n    } else {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1)) / \n        metrics.executions;\n    }\n    \n    // Calculate throughput (executions per minute)\n    const timeWindow = 60000; // 1 minute\n    metrics.throughput = (metrics.executions / duration) * timeWindow;\n  }\n\n  private async rollbackPipeline(\n    pipeline: HookPipeline,\n    results: HookHandlerResult[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.warn(`Rolling back pipeline '${pipeline.name}'`);\n    // Implement rollback logic based on side effects in results\n    // This is a placeholder for actual rollback implementation\n  }\n\n  private getTotalHookCount(): number {\n    let count = 0;\n    for (const hookList of this.hooks.values()) {\n      count += hookList.length;\n    }\n    return count;\n  }\n\n  private initializeMetrics(): void {\n    this.metrics.set('hooks.registered', 0);\n    this.metrics.set('hooks.unregistered', 0);\n    this.metrics.set('hooks.executions', 0);\n    this.metrics.set('hooks.errors', 0);\n    this.metrics.set('hooks.cacheHits', 0);\n    this.metrics.set('hooks.totalDuration', 0);\n  }\n\n  private updateMetric(key: string, value: number): void {\n    const current = this.metrics.get(key) || 0;\n    this.metrics.set(key, current + value);\n  }\n\n  private generateExecutionId(): string {\n    return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generatePipelineId(): string {\n    return `pipe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getCachedResult(\n    hookId: string, \n    cacheKey: string\n  ): HookHandlerResult | null {\n    // Implement cache retrieval\n    // This is a placeholder\n    return null;\n  }\n\n  private cacheResult(\n    hookId: string,\n    cacheKey: string,\n    result: HookHandlerResult,\n    ttl: number\n  ): void {\n    // Implement cache storage\n    // This is a placeholder\n  }\n\n  private async withTimeout<T>(\n    promise: Promise<T>,\n    timeout: number,\n    message: string\n  ): Promise<T> {\n    return Promise.race([\n      promise,\n      new Promise<T>((_, reject) => \n        setTimeout(() => reject(new Error(message)), timeout)\n      ),\n    ]);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Export singleton instance\nexport const agenticHookManager = new AgenticHookManager();"],"names":["EventEmitter","Logger","logger","level","format","destination","prefix","AgenticHookManager","hooks","Map","pipelines","metrics","activeExecutions","Set","initializeMetrics","register","registration","type","id","validateRegistration","has","set","hookList","get","some","h","Error","insertIndex","findIndex","priority","push","splice","info","emit","updateMetric","unregister","found","entries","index","length","delete","getHooks","filter","hook","matchesFilter","executeHooks","payload","context","executionId","generateExecutionId","add","startTime","Date","now","results","createFilterFromPayload","debug","count","modifiedPayload","result","executeHook","sideEffects","processSideEffects","modified","continue","error","handleHookError","options","errorHandler","duration","createPipeline","config","pipeline","generatePipelineId","name","stages","errorStrategy","executions","avgDuration","errorRate","throughput","executePipeline","pipelineId","initialPayload","currentPayload","stage","condition","stageResults","executeStage","transform","i","lastModified","reverse","find","r","updatePipelineMetrics","rollbackPipeline","getMetrics","key","value","getTotalHookCount","Array","from","keys","size","handler","providers","hasProvider","p","includes","models","hasModel","m","patterns","conditions","provider","model","operations","operation","namespaces","namespace","Object","undefined","cache","enabled","cacheKey","cached","getCachedResult","resultPromise","timeout","withTimeout","cacheResult","ttl","retries","warn","retryHook","fallback","retriesLeft","delay","Math","pow","effect","processSideEffect","processMemorySideEffect","processNeuralSideEffect","processMetricSideEffect","processNotificationSideEffect","processLogSideEffect","action","data","message","hookId","parallel","promises","map","Promise","all","hasError","timeWindow","values","current","random","toString","substr","promise","race","_","reject","setTimeout","ms","resolve","agenticHookManager"],"mappings":"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"}